<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PDSCH end-to-end communication &mdash; NeoRadium 0.2.0 Documentation</title>
      <link rel="stylesheet" href="../../../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../../_static/nbsphinx-code-cells.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../../_static/neoradium.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../../../_static/jquery.js"></script>
        <script src="../../../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../../../../../" id="documentation_options" src="../../../../../../_static/documentation_options.js"></script>
        <script src="../../../../../../_static/doctools.js"></script>
        <script src="../../../../../../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../index.html" class="icon icon-home">
            NeoRadium 0.2.0
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../index.html">What is NeoRadium?</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../source/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../source/Playground/Playground.html">Playground</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../source/API/Carrier.html">Carriers and Bandwidth Parts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../source/API/Grid.html">Resource Grid</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../source/API/Waveform.html">Waveform</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../source/API/Modulation.html">Modulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../source/API/RefSig.html">Reference Signals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../source/API/PhyChannels.html">Physical Channels</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../source/API/ChanCode.html">Channel Coding</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../source/API/Antenna.html">Antenna</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../source/API/Channels.html">Channel Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../source/API/Random.html">Random Number Generator</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../index.html">NeoRadium 0.2.0</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">PDSCH end-to-end communication</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../_sources/html/html/source/Playground/Notebooks/PDSCH/PDSCH-endToEnd.ipynb.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="PDSCH-end-to-end-communication">
<h1>PDSCH end-to-end communication<a class="headerlink" href="#PDSCH-end-to-end-communication" title="Permalink to this heading"></a></h1>
<p>This notebook shows how an end-to-end communication through a 5G Physical Downlink Shared Channel (PDSCH) can be simulated in <strong>NeoRadium</strong> based on 3GPP NR standard. It demonstrate the following steps:</p>
<ul class="simple">
<li><p>Creating LDPC encoder object and using it to perform transport block segmentation, LDPC encoding and rate matching based on 3GPP TS 38.212.</p></li>
<li><p>Creating a <code class="docutils literal notranslate"><span class="pre">PDSCH</span></code> object and using it to populate a transmitted resource grid based on the encoded transport blocks. During this process, the PDSCH also adds DMRS reference signals in the resource grid based on 3GPP TS 38.211 and TS 38.214.</p></li>
<li><p>Creating a CDL channel model as specified in 3GPP TR 38.901 using the <code class="docutils literal notranslate"><span class="pre">CdlChannel</span></code> class. This class and the resource gird created by the <code class="docutils literal notranslate"><span class="pre">PDSCH</span></code>, are used to calculate a precoding matrix which is then used to precode the resource grid.</p></li>
<li><p>Converting the precoded resource grid to a time-domain (transmitted) waveform through OFDM modulation performed by the <code class="docutils literal notranslate"><span class="pre">ofdmModulate</span></code> method of the <code class="docutils literal notranslate"><span class="pre">Grid</span></code> class.</p></li>
<li><p>Applying the CDL channel to the transmitted waveform to obtain the received waveform.</p></li>
<li><p>Synchronizing the received waveform by calculating the timing offset using the CDL class object.</p></li>
<li><p>Applying OFDM demodulation to the synchronized received waveform to get a received resource grid.</p></li>
<li><p>Estimating the channel matrix using the DMRS reference signals.</p></li>
<li><p>Equalizing the received resource grid using Minimum mean-squared error (MMSE) equalization to cancel the effect of communication channel.</p></li>
<li><p>Using the <code class="docutils literal notranslate"><span class="pre">getLLRsFromGrid</span></code> function of <code class="docutils literal notranslate"><span class="pre">PDSCH</span></code> class to extract log-likelihood ratios from the received resource grid.</p></li>
<li><p>Recovering the rate and then LDPC-decoding the transport blocks from the log-likelihood ratios.</p></li>
<li><p>Comparing the received bitstream with the original values used at the beginning of the pipeline.</p></li>
</ul>
<img alt="PDSCH-Pipeline" src="html/html/source/Playground/Notebooks/PDSCH/PDSCH-Pipeline.png" />
<p>Let’s get started by importing the <strong>NewRadium</strong> modules used in the notebook.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.io</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="kn">from</span> <span class="nn">neoradium</span> <span class="kn">import</span> <span class="n">Carrier</span><span class="p">,</span> <span class="n">PDSCH</span><span class="p">,</span> <span class="n">CdlChannel</span><span class="p">,</span> <span class="n">AntennaPanel</span><span class="p">,</span> <span class="n">LdpcEncoder</span><span class="p">,</span> <span class="n">Grid</span>
<span class="kn">from</span> <span class="nn">neoradium.utils</span> <span class="kn">import</span> <span class="n">random</span>
<br/></pre></div>
</div>
</div>
<section id="Carrier-Configuration">
<h2>Carrier Configuration<a class="headerlink" href="#Carrier-Configuration" title="Permalink to this heading"></a></h2>
<p>Here using the <code class="docutils literal notranslate"><span class="pre">Carrier</span></code> class we define a carrier with 30 KHz subcarrier spacing with 51 resource blocks. The print function prints information about the carrier. Please note that by default a single bandwidth part is defined which covers the whole carrier. Additional bandwidth parts can be added to the carrier if needed.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">carrier</span> <span class="o">=</span> <span class="n">Carrier</span><span class="p">(</span><span class="n">numRbs</span><span class="o">=</span><span class="mi">51</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>  <span class="c1"># 51*12*30000 = 18,360,000 for 20 MHz Bandwidth</span>
<span class="n">carrier</span><span class="o">.</span><span class="n">print</span><span class="p">()</span>
<span class="n">bwp</span> <span class="o">=</span> <span class="n">carrier</span><span class="o">.</span><span class="n">curBwp</span>                      <span class="c1"># The only bandwidth part in the carrier</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>

Carrier Properties:
  startRb: 0
  numRbs: 51
  Cell Id: 1
  Active Bandwidth Part: 0
  Bandwidth Parts: 1
  Bandwidth Part 0:
    Resource Blocks: 51 RBs starting at 0 (612 subcarriers)
    Subcarrier Spacing: 30 KHz
    CP Type: normal
    bandwidth: 18360000 Hz
    symbolsPerSlot: 14
    slotsPerSubFrame: 2
    nFFT: 1024

</pre></div></div>
</div>
</section>
<section id="PDSCH-and-DMRS-Configuration">
<h2>PDSCH and DMRS Configuration<a class="headerlink" href="#PDSCH-and-DMRS-Configuration" title="Permalink to this heading"></a></h2>
<p>Now let’s use the <code class="docutils literal notranslate"><span class="pre">PDSCH</span></code> class to configure the PDSCH communication parameters. Here we choose “Mapping Type A” and “QAM16” modulation (by default). We also set the number of layers to 2 and disable interleaving by setting <code class="docutils literal notranslate"><span class="pre">interleavingBundleSize</span></code> to zero.</p>
<p>We then set the DMRS configuration using the <code class="docutils literal notranslate"><span class="pre">setDMRD</span></code> method of the <code class="docutils literal notranslate"><span class="pre">PDSCH</span></code> class. Here we use DMRS <code class="docutils literal notranslate"><span class="pre">configType</span></code> set to 2 with 2 additional symbol time allocations (<code class="docutils literal notranslate"><span class="pre">additionalPos=2</span></code>). Although <strong>NeoRadium</strong> supports both wide band and narrow band precoding, we set the “Precoding RB Group (PRG)” size to 0 which means the same precoding is used for all subcarriers (Wideband Precoding).</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pdsch</span> <span class="o">=</span> <span class="n">PDSCH</span><span class="p">(</span><span class="n">bwp</span><span class="p">,</span> <span class="n">interleavingBundleSize</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">numLayers</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nID</span><span class="o">=</span><span class="n">carrier</span><span class="o">.</span><span class="n">cellId</span><span class="p">)</span>
<span class="n">pdsch</span><span class="o">.</span><span class="n">setDMRS</span><span class="p">(</span><span class="n">prgSize</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">configType</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">additionalPos</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">pdsch</span><span class="o">.</span><span class="n">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>

PDSCH Properties:
  mappingType: A
  nID: 1
  rnti: 1
  numLayers: 2
  numCodewords: 1
  modulation: 16QAM
  portSet: [0, 1]
  symSet:   0   1   2   3   4   5   6   7   8   9  10  11  12  13
  prbSet:   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19
           20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39
           40  41  42  43  44  45  46  47  48  49  50
  interleavingBundleSize: 0
  PRG Size: Wideband
  Bandwidth Part:
    Resource Blocks: 51 RBs starting at 0 (612 subcarriers)
    Subcarrier Spacing: 30 KHz
    CP Type: normal
    bandwidth: 18360000 Hz
    symbolsPerSlot: 14
    slotsPerSubFrame: 2
    nFFT: 1024
  DMRS:
    configType: 2
    nIDs: []
    scID: 0
    sameSeq: 1
    symbols: Single
    typeA1stPos: 2
    additionalPos: 2
    cdmGroups: [0, 0]
    deltaShifts: [0, 0]
    allCdmGroups: [0]
    symSet: [ 2  7 11]
    REs (before shift): [0, 1, 6, 7]
    epreRatioDb: 0 (db)

</pre></div></div>
</div>
</section>
<section id="Channel-Coding-Configuration">
<h2>Channel Coding Configuration<a class="headerlink" href="#Channel-Coding-Configuration" title="Permalink to this heading"></a></h2>
<p>Now it is time to define the parameters of LDPC channel coding. <strong>NeoRadium</strong> provides the <code class="docutils literal notranslate"><span class="pre">LdpcEncoder</span></code> and <code class="docutils literal notranslate"><span class="pre">LdpcDecoder</span></code> classes. These classes can be used to perform data segmentation/de-segmentation, rate-matching/rate-recovery, and encoding/decoding. Here we first set our desired code rate, then create an <code class="docutils literal notranslate"><span class="pre">LdpcEncoder</span></code> object that will be used for LDPC encoding.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">codeRate</span> <span class="o">=</span> <span class="mi">490</span><span class="o">/</span><span class="mi">1024</span>
<span class="n">ldpcEncoder</span> <span class="o">=</span> <span class="n">LdpcEncoder</span><span class="p">(</span><span class="n">baseGraphNo</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">modulation</span><span class="o">=</span><span class="n">pdsch</span><span class="o">.</span><span class="n">modems</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">modulation</span><span class="p">,</span>
                          <span class="n">txLayers</span><span class="o">=</span><span class="n">pdsch</span><span class="o">.</span><span class="n">numLayers</span><span class="p">,</span> <span class="n">targetRate</span><span class="o">=</span><span class="n">codeRate</span><span class="p">)</span>
<br/></pre></div>
</div>
</div>
</section>
<section id="Resource-Grid-Creation-and-Mapping">
<h2>Resource Grid Creation and Mapping<a class="headerlink" href="#Resource-Grid-Creation-and-Mapping" title="Permalink to this heading"></a></h2>
<p>Now that we have created the PDSCH and LDPC encoder objects, we can use them to perform channel coding and resource mapping. In the following cell, we first create a resource grid object using the <code class="docutils literal notranslate"><span class="pre">getGrid</span></code> method of the <code class="docutils literal notranslate"><span class="pre">PDSCH</span></code> object. This will create a resource grid, creates the DMRS reference signals and puts them in the specified locations in the resource grid.</p>
<p>The method <code class="docutils literal notranslate"><span class="pre">getTxBlockSize</span></code> is used to calculate the transport block size(s) based on the resources available in the grid for data transmission at the specified code rate. This function calculates the the transport block size based on 3GPP TS 38.214.</p>
<p>Once we have the transport block size, we create random bits for transmission using the utility function <code class="docutils literal notranslate"><span class="pre">bits</span></code> of <strong>NeoRadium</strong>’s <code class="docutils literal notranslate"><span class="pre">random</span></code> module.</p>
<p>The function <code class="docutils literal notranslate"><span class="pre">getBitSizes</span></code> returns total bit capacity of the resource grid for each code word. This is the total number of encoded data bits that can be transmitted using the resource grid. It is used to perform rate-matching by the <code class="docutils literal notranslate"><span class="pre">LdpcEncoder</span></code> class.</p>
<p>The function <code class="docutils literal notranslate"><span class="pre">getRateMatchedCodeWords</span></code> performs segmentation, rate-matching, and LDPC encoding in a single call. The output contains the encoded bits for each codeword.</p>
<p>Once we have the rated-matched encoded bits, we can map them to the available resources in the resource grid. This is exactly what the <code class="docutils literal notranslate"><span class="pre">populateGrid</span></code> method of the <code class="docutils literal notranslate"><span class="pre">PDSCH</span></code> class does. This function first converts bits to complex symbols using the QAM modulation and then assigns the symbols to the available resource elements in the resource grid at different time, frequency, and layer locations.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">drawMap</span></code> method of the <code class="docutils literal notranslate"><span class="pre">Grid</span></code> class is used here to show the allocation of data and DMRS in the resource grid.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">random</span><span class="o">.</span><span class="n">setSeed</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>                          <span class="c1"># Making the results reproducible.</span>
<span class="n">grid</span> <span class="o">=</span> <span class="n">pdsch</span><span class="o">.</span><span class="n">getGrid</span><span class="p">()</span>                       <span class="c1"># Create a resource grid already populated with DMRS</span>
<span class="n">txBlockSize</span> <span class="o">=</span> <span class="n">pdsch</span><span class="o">.</span><span class="n">getTxBlockSize</span><span class="p">(</span><span class="n">codeRate</span><span class="p">)</span> <span class="c1"># Calculate the Transport Block Size based on 3GPP TS 38.214</span>
<span class="n">txBlock</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">bits</span><span class="p">(</span><span class="n">txBlockSize</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>        <span class="c1"># Create random binary data</span>

<span class="n">numBits</span> <span class="o">=</span> <span class="n">pdsch</span><span class="o">.</span><span class="n">getBitSizes</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>            <span class="c1"># Actual number of bits available in the resource grid</span>

<span class="c1"># Now perform the segmentation, rate-matching, and encoding in one call:</span>
<span class="n">rateMatchedCodeWords</span> <span class="o">=</span> <span class="n">ldpcEncoder</span><span class="o">.</span><span class="n">getRateMatchedCodeWords</span><span class="p">(</span><span class="n">txBlock</span><span class="p">,</span> <span class="n">numBits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="c1"># Now populate the resource grid with coded data. This includes QAM modulation and resource mapping.</span>
<span class="n">pdsch</span><span class="o">.</span><span class="n">populateGrid</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">rateMatchedCodeWords</span><span class="p">)</span>

<span class="c1"># Store the indexes of the PDSCH data in pdschIndexes to be used later.</span>
<span class="n">pdschIndexes</span> <span class="o">=</span> <span class="n">pdsch</span><span class="o">.</span><span class="n">getReIndexes</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="s2">&quot;PDSCH&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;TX Block Size:&quot;</span><span class="p">,</span> <span class="n">txBlockSize</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of bits:&quot;</span><span class="p">,</span> <span class="n">numBits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Size of the rate-matched coded block:&quot;</span><span class="p">,</span> <span class="n">rateMatchedCodeWords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="c1"># Get statistics about the grid resource allocation</span>
<span class="n">gridStats</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">getStats</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Grid Allocation Stats:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">gridStats</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  </span><span class="si">%s</span><span class="s2">: </span><span class="si">%d</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>

<span class="c1"># Draw the map of grid showing the data and DMRS in the first RB of the BWP.</span>
<span class="n">grid</span><span class="o">.</span><span class="n">drawMap</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
TX Block Size: 30216
Number of bits: 63648
Size of the rate-matched coded block: 63648
Grid Allocation Stats:
  GridSize: 17136
  DMRS: 1224
  PDSCH: 15912
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../../../../../../_images/html_html_source_Playground_Notebooks_PDSCH_PDSCH-endToEnd_9_1.png" src="../../../../../../_images/html_html_source_Playground_Notebooks_PDSCH_PDSCH-endToEnd_9_1.png" />
</div>
</div>
</section>
<section id="Channel-Simulation-and-Precoding">
<h2>Channel Simulation and Precoding<a class="headerlink" href="#Channel-Simulation-and-Precoding" title="Permalink to this heading"></a></h2>
<p>The next step in the pipeline is the precoding process. In practice the precoding information is extracted at the UE side (The receiver in this case) from the estimated channel. Since we are demonstrating only a downlink communication here, we assume that the precoding matrix is somehow available.</p>
<p>To calculate the precoding matrix we first need to define the channel model. Here we use a CDL channel model as specified in 3GPP TR 38.901. The <code class="docutils literal notranslate"><span class="pre">CdlChannel</span></code> class is used to create a channel model object. Here we are using a CDL-C model which simulates NLOS communication. We use delay spread of 300 ns and a doppler shift of 5 Hz. We also use a small MIMO configuration with 8 transmitter antenna and 2 receiver antenna. The <code class="docutils literal notranslate"><span class="pre">print</span></code> function of the <code class="docutils literal notranslate"><span class="pre">CdlChannel</span></code> class can be used to show all
properties of the CDL channel model.</p>
<p>To calculate the precoding matrix, we first get the channel matrix from the <code class="docutils literal notranslate"><span class="pre">CdlChannel</span></code> object. The channel matrix is a 4-D complex tensor of size <code class="docutils literal notranslate"><span class="pre">l</span></code>x<code class="docutils literal notranslate"><span class="pre">k</span></code>x <code class="docutils literal notranslate"><span class="pre">Nr</span></code>x<code class="docutils literal notranslate"><span class="pre">Nt</span></code>. Where <code class="docutils literal notranslate"><span class="pre">l</span></code>, <code class="docutils literal notranslate"><span class="pre">k</span></code>, <code class="docutils literal notranslate"><span class="pre">Nr</span></code>, and <code class="docutils literal notranslate"><span class="pre">Nt</span></code> are the number of time symbols (14), the number of subcarriers (51x12=612), the number of receiver antenna (2), and the number of transmitter antenna (8) respectively.</p>
<p>Once we have the channel matrix, the <code class="docutils literal notranslate"><span class="pre">getPrecodingMatrix</span></code> method of the <code class="docutils literal notranslate"><span class="pre">PDSCH</span></code> class is called to calculate and return the precoding matrix.</p>
<p>To precode the resource grid, we simply call the <code class="docutils literal notranslate"><span class="pre">precode</span></code> method of the <code class="docutils literal notranslate"><span class="pre">Grid</span></code> class passing in the precoding matrix.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Creating a CdlChannel object:</span>
<span class="n">f0</span> <span class="o">=</span> <span class="mf">4e9</span>  <span class="c1"># Carrier Frequency</span>
<span class="n">channel</span> <span class="o">=</span> <span class="n">CdlChannel</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">delaySpread</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">carrierFreq</span><span class="o">=</span><span class="n">f0</span><span class="p">,</span> <span class="n">dopplerShift</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                     <span class="n">txAntenna</span> <span class="o">=</span> <span class="n">AntennaPanel</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">polarization</span><span class="o">=</span><span class="s2">&quot;|&quot;</span><span class="p">),</span>  <span class="c1"># 8 TX antenna</span>
                     <span class="n">rxAntenna</span> <span class="o">=</span> <span class="n">AntennaPanel</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">polarization</span><span class="o">=</span><span class="s2">&quot;|&quot;</span><span class="p">))</span>  <span class="c1"># 2 RX antenna</span>
<span class="c1"># channel.print()                                       # Unremark to pring all channel information</span>

<span class="c1"># Getting the Precoding Matrix, and precoding the resource grid</span>
<span class="n">channelMatrix</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">getChannelMatrix</span><span class="p">(</span><span class="n">bwp</span><span class="p">)</span>           <span class="c1"># Get the channel matrix</span>
<span class="n">precoder</span> <span class="o">=</span> <span class="n">pdsch</span><span class="o">.</span><span class="n">getPrecodingMatrix</span><span class="p">(</span><span class="n">channelMatrix</span><span class="p">)</span>      <span class="c1"># Get the precoder matrix from the PDSCH object</span>
<span class="n">precodedGrid</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">precode</span><span class="p">(</span><span class="n">precoder</span><span class="p">)</span>                   <span class="c1"># Perform the precoding</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape of Channel Matrix:        &quot;</span><span class="p">,</span> <span class="n">channelMatrix</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape of Resource Grid:         &quot;</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape of Precoded Resource Grid:&quot;</span><span class="p">,</span> <span class="n">precodedGrid</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<br/></pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Shape of Channel Matrix:         (14, 612, 2, 8)
Shape of Resource Grid:          (2, 14, 612)
Shape of Precoded Resource Grid: (8, 14, 612)
</pre></div></div>
</div>
</section>
<section id="OFDM-Modulation">
<h2>OFDM Modulation<a class="headerlink" href="#OFDM-Modulation" title="Permalink to this heading"></a></h2>
<p>To transmit the precoded resource grid it first needs to be transformed to time-domain. The method <code class="docutils literal notranslate"><span class="pre">ofdmModulate</span></code> of the <code class="docutils literal notranslate"><span class="pre">Grid</span></code> class converts the precoded grid into a set of time-domain waveforms for each transmit antenna. The output of the OFDM modulation is a <code class="docutils literal notranslate"><span class="pre">Waveform</span></code> class that contains the waveforms for each transmit antenna.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">txWaveform</span> <span class="o">=</span> <span class="n">precodedGrid</span><span class="o">.</span><span class="n">ofdmModulate</span><span class="p">()</span>
<span class="c1"># txWaveform contains the waveforms in time domain for each transmitter antenna</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape of txWaveform:&quot;</span><span class="p">,</span> <span class="n">txWaveform</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Shape of txWaveform: (8, 15360)
</pre></div></div>
</div>
</section>
<section id="Applying-the-channel-model-to-the-transmitted-waveform">
<h2>Applying the channel model to the transmitted waveform<a class="headerlink" href="#Applying-the-channel-model-to-the-transmitted-waveform" title="Permalink to this heading"></a></h2>
<p>Now we need to pass the transmitted waveform through our CDL channel model. Since channel models usually delay the signals, to make sure we get the whole waveform on the output end of the channel, we need to append some zeros to the end of the waveform. The number of these zeros depend on the maximum channel delay that can be obtained using the <code class="docutils literal notranslate"><span class="pre">getMaxDelay</span></code> method of the <code class="docutils literal notranslate"><span class="pre">CdlChannel</span></code> class. The <code class="docutils literal notranslate"><span class="pre">pad</span></code> method of <code class="docutils literal notranslate"><span class="pre">Waveform</span></code> class append zeros to the end of waveform.</p>
<p>Now the channel model can be applied to the transmitted waveform to obtain the received waveform. This is exactly what the <code class="docutils literal notranslate"><span class="pre">applyToSignal</span></code> method of the <code class="docutils literal notranslate"><span class="pre">CdlChannel</span></code> class does. The output is another <code class="docutils literal notranslate"><span class="pre">Waveform</span></code> object containing the received waveform for each receiver antenna.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Need to append zeros to the end of signal based on the maximum channel delay</span>
<span class="n">maxDelay</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">getMaxDelay</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Max Channel Delay:  &quot;</span><span class="p">,</span> <span class="n">maxDelay</span><span class="p">)</span>
<span class="n">txWaveform</span> <span class="o">=</span> <span class="n">txWaveform</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">maxDelay</span><span class="p">)</span>

<span class="c1"># Applying channel to the transmitted signal</span>
<span class="n">rxWaveform</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">applyToSignal</span><span class="p">(</span><span class="n">txWaveform</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape of rxWaveform:&quot;</span><span class="p">,</span> <span class="n">rxWaveform</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Max Channel Delay:   87
Shape of rxWaveform: (2, 15447)
</pre></div></div>
</div>
</section>
<section id="Adding-Noise">
<h2>Adding Noise<a class="headerlink" href="#Adding-Noise" title="Permalink to this heading"></a></h2>
<p>We can use the <code class="docutils literal notranslate"><span class="pre">addNoise</span></code> method of the <code class="docutils literal notranslate"><span class="pre">Waveform</span></code> class to add AWGN to the received signal. Since we are adding the noise in the time-domain, the FFT size is also used in the calculation noise variance. So, we are passing both SNR value and the FFT size to the <code class="docutils literal notranslate"><span class="pre">addNoise</span></code> method.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">noisyRxWaveform</span> <span class="o">=</span> <span class="n">rxWaveform</span><span class="o">.</span><span class="n">addNoise</span><span class="p">(</span><span class="n">snrDb</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">nFFT</span><span class="o">=</span><span class="n">bwp</span><span class="o">.</span><span class="n">nFFT</span><span class="p">)</span>
<br/></pre></div>
</div>
</div>
</section>
<section id="Synchronization-and-OFDM-Demodulation">
<h2>Synchronization and OFDM Demodulation<a class="headerlink" href="#Synchronization-and-OFDM-Demodulation" title="Permalink to this heading"></a></h2>
<p>Because of multiple different path delays involved in the channel model, we need to find the best starting point in the received waveform. This is usually done by finding the position of maximum correlation between the received signal and reference signals. The function <code class="docutils literal notranslate"><span class="pre">getTimingOffset</span></code> of the <code class="docutils literal notranslate"><span class="pre">CdlChannel</span></code> provides this “timing offset” which is the number of samples we need to skip from the beginning of the received waveform.</p>
<p>After synchronization, the waveform can be used for OFDM demodulation to the received resource grid. The class method <code class="docutils literal notranslate"><span class="pre">ofdmDemodulate</span></code> creates a <code class="docutils literal notranslate"><span class="pre">Grid</span></code> class instance containing the received resource grid.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Synchronization: Get the timing offset</span>
<span class="n">offset</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">getTimingOffset</span><span class="p">()</span>
<span class="n">syncedWaveform</span> <span class="o">=</span> <span class="n">noisyRxWaveform</span><span class="o">.</span><span class="n">sync</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Timing Offset:                  &quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>

<span class="c1"># OFDM Demodulation</span>
<span class="n">rxGrid</span> <span class="o">=</span> <span class="n">syncedWaveform</span><span class="o">.</span><span class="n">ofdmDemodulate</span><span class="p">(</span><span class="n">bwp</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape of received resource grid:&quot;</span><span class="p">,</span> <span class="n">rxGrid</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Timing Offset:                   13
Shape of received resource grid: (2, 14, 612)
</pre></div></div>
</div>
</section>
<section id="Applying-channel-in-Frequency-Domain">
<h2>Applying channel in Frequency Domain<a class="headerlink" href="#Applying-channel-in-Frequency-Domain" title="Permalink to this heading"></a></h2>
<p>You can also use a shortcut method of applying the channel model to the transmitted grid directly without going to time domain. Although this is not exactly what happens in practice, it is sometimes useful (or convenient) to avid the time domain.</p>
<p>The method <code class="docutils literal notranslate"><span class="pre">applyChannel</span></code> of the <code class="docutils literal notranslate"><span class="pre">Grid</span></code> class can be used to apply a channel matrix to a resource grid. For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># Applying the channel matrix to the precoded grid
rxGrid = precodedGrid.applyChannel(channelMatrix)
</pre></div>
</div>
</section>
<section id="Channel-Estimation">
<h2>Channel Estimation<a class="headerlink" href="#Channel-Estimation" title="Permalink to this heading"></a></h2>
<p>The input to the channel estimation process is the received resource grid and the known reference signals (in this case DMRS) and the output is the estimated channel. Note that in this case the estimated channel includes the precoding process. That is because the DMRS reference signals were added to the resource grid <strong>before</strong> precoding.</p>
<section id="Perfect-Channel-Estimation">
<h3>Perfect Channel Estimation<a class="headerlink" href="#Perfect-Channel-Estimation" title="Permalink to this heading"></a></h3>
<p>For perfect channel estimation, we need to apply precoding to the channel matrix. This can be done by a simple matrix multiplication as shown in the following cell.</p>
</section>
<section id="Practical-Channel-Estimation">
<h3>Practical Channel Estimation<a class="headerlink" href="#Practical-Channel-Estimation" title="Permalink to this heading"></a></h3>
<p>The method <code class="docutils literal notranslate"><span class="pre">estimateChannelLS</span></code> of the <code class="docutils literal notranslate"><span class="pre">Grid</span></code> class can be used to estimate the channel matrix. This method performs CDM averaging, Least-Squared channel estimation at pilot locations, and applying interpolation to get the whole channel matrix.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Perfect channel estimation (Applying the precoding to the channel matrix)</span>
<span class="c1"># estChannelMatrix = channelMatrix @ precoder[None,...]</span>

<span class="c1"># Practical channel estimation</span>
<span class="n">estChannelMatrix</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">rxGrid</span><span class="o">.</span><span class="n">estimateChannelLS</span><span class="p">(</span><span class="n">pdsch</span><span class="o">.</span><span class="n">dmrs</span><span class="p">)</span>    <span class="c1"># Un-remark to use practical channel estimation</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape of estimated channel:&quot;</span><span class="p">,</span> <span class="n">estChannelMatrix</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<br/></pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Shape of estimated channel: (14, 612, 2, 2)
</pre></div></div>
</div>
</section>
</section>
<section id="Equalization">
<h2>Equalization<a class="headerlink" href="#Equalization" title="Permalink to this heading"></a></h2>
<p>Now that we have an estimation of channel matrix, we can use it for equalization. The method <code class="docutils literal notranslate"><span class="pre">equalize</span></code> of the <code class="docutils literal notranslate"><span class="pre">Grid</span></code> class uses the Minimum mean-squared error (MMSE) equalization algorithm to cancel the effect of the channel in the received resource grid.</p>
<p>It outputs a <code class="docutils literal notranslate"><span class="pre">Grid</span></code> object containing the equalized received resource grid and the LLR scaling values which is used later to scale the log-likelihood ratios from the demodulation process.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">eqGrid</span><span class="p">,</span> <span class="n">llrScales</span> <span class="o">=</span> <span class="n">rxGrid</span><span class="o">.</span><span class="n">equalize</span><span class="p">(</span><span class="n">estChannelMatrix</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape of equalized grid:&quot;</span><span class="p">,</span> <span class="n">eqGrid</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape of LLR Scales:    &quot;</span><span class="p">,</span> <span class="n">llrScales</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Shape of equalized grid: (2, 14, 612)
Shape of LLR Scales:     (2, 14, 612)
</pre></div></div>
</div>
</section>
<section id="Demodulation,-De-mapping,-Descrambling">
<h2>Demodulation, De-mapping, Descrambling<a class="headerlink" href="#Demodulation,-De-mapping,-Descrambling" title="Permalink to this heading"></a></h2>
<p>The method <code class="docutils literal notranslate"><span class="pre">getLLRsFromGrid</span></code> of the <code class="docutils literal notranslate"><span class="pre">PDSCH</span></code> object performs demodulation, de-mapping, and descrambling of the received grid in one call. The output of this process is a set of log-likelihood ratios (LLRs) for the each received codeword extracted from the received resource grid. Note that in this example there is only one codeword.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">llrs</span> <span class="o">=</span> <span class="n">pdsch</span><span class="o">.</span><span class="n">getLLRsFromGrid</span><span class="p">(</span><span class="n">eqGrid</span><span class="p">,</span> <span class="n">pdschIndexes</span><span class="p">,</span> <span class="n">llrScales</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Length of LLRs for the first code-word:&quot;</span><span class="p">,</span> <span class="n">llrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Length of LLRs for the first code-word: 63648
</pre></div></div>
</div>
</section>
<section id="Rate-Recovery-and-LDPC-decoding">
<h2>Rate Recovery and LDPC decoding<a class="headerlink" href="#Rate-Recovery-and-LDPC-decoding" title="Permalink to this heading"></a></h2>
<p>We are close to the end of pipeline. We just need to decode the LLRs to the actual transport blocks. To do this, we need an LDPC decoder object. The method <code class="docutils literal notranslate"><span class="pre">getDecoder</span></code> of the <code class="docutils literal notranslate"><span class="pre">LdpcEncoder</span></code> class conveniently creates a decoder object matching the parameters of the encoder.</p>
<p>The function <code class="docutils literal notranslate"><span class="pre">recoverRate</span></code> of the LDPC decoder object can then be used to recover the rate of LDPC codewords based on the transport block size. This is based on the procedure specified in 3GPP TS 38.212.</p>
<p>The rate-recovered coded blocks are then ready to be LDPC-decoded using the <code class="docutils literal notranslate"><span class="pre">decode</span></code> method of the <code class="docutils literal notranslate"><span class="pre">LdpcDecoder</span></code> class (Each coded block is decoded separately). The output is a set of the decoded blocks.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create an LDPC Decoder object using the same parameters used to create the encoder.</span>
<span class="n">ldpcDecoder</span> <span class="o">=</span> <span class="n">ldpcEncoder</span><span class="o">.</span><span class="n">getDecoder</span><span class="p">()</span>

<span class="c1"># Do rate recovery (Note: We have only one codeword in this example)</span>
<span class="n">rxCodedBlocks</span> <span class="o">=</span> <span class="n">ldpcDecoder</span><span class="o">.</span><span class="n">recoverRate</span><span class="p">(</span><span class="n">llrs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">txBlockSize</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape of rxCodedBlocks: &quot;</span><span class="p">,</span> <span class="n">rxCodedBlocks</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

<span class="c1"># LDPC-Decoding</span>
<span class="n">decodedBlocks</span> <span class="o">=</span> <span class="n">ldpcDecoder</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">rxCodedBlocks</span><span class="p">,</span> <span class="n">numIter</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape of Decoded Blocks:&quot;</span><span class="p">,</span> <span class="n">decodedBlocks</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<br/><br/></pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Shape of rxCodedBlocks:  (4, 23232)
Shape of Decoded Blocks: (4, 7744)
</pre></div></div>
</div>
</section>
<section id="CRC-checking-and-De-segmentation">
<h2>CRC checking and De-segmentation<a class="headerlink" href="#CRC-checking-and-De-segmentation" title="Permalink to this heading"></a></h2>
<p>The CRC of each decoded block must be checked and then the decoded blocks need to be merged (de-segmented) to provide the transport blocks. The method <code class="docutils literal notranslate"><span class="pre">checkCrcAndMerge</span></code> of the <code class="docutils literal notranslate"><span class="pre">LdpcDecoder</span></code> class does exactly this. The output of this method is a decoded transport block wich also contains a transport block CRC appended at the end.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">checkCrc</span></code> method of the <code class="docutils literal notranslate"><span class="pre">LdpcDecoder</span></code> class can be used to check the transport block CRC.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">decodedTxBlockWithCRC</span><span class="p">,</span> <span class="n">crcMatch</span> <span class="o">=</span> <span class="n">ldpcDecoder</span><span class="o">.</span><span class="n">checkCrcAndMerge</span><span class="p">(</span><span class="n">decodedBlocks</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape of decoded transport block:&quot;</span><span class="p">,</span> <span class="n">decodedTxBlockWithCRC</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;CRC Match for each decoded block:&quot;</span><span class="p">,</span> <span class="n">crcMatch</span><span class="p">)</span>

<span class="n">txBlockCrcMatch</span> <span class="o">=</span> <span class="n">ldpcDecoder</span><span class="o">.</span><span class="n">checkCrc</span><span class="p">(</span><span class="n">decodedTxBlockWithCRC</span><span class="p">,</span><span class="s1">&#39;24A&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Transport block CRC Match:       &quot;</span><span class="p">,</span> <span class="n">txBlockCrcMatch</span><span class="p">)</span>
<br/></pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Shape of decoded transport block: (30240,)
CRC Match for each decoded block: [ True  True  True  True]
Transport block CRC Match:        True
</pre></div></div>
</div>
</section>
<section id="Comparing-the-decoded-transport-block-with-the-original">
<h2>Comparing the decoded transport block with the original<a class="headerlink" href="#Comparing-the-decoded-transport-block-with-the-original" title="Permalink to this heading"></a></h2>
<p>We can get the decoded transport block by removing the 24-bit CRC at the end. Then we can compare the results with the original transport block that was created randomly at the beginning of this pipeline.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">decodedTxBlock</span> <span class="o">=</span> <span class="n">decodedTxBlockWithCRC</span><span class="p">[:</span><span class="o">-</span><span class="mi">24</span><span class="p">]</span>  <span class="c1"># remove the transport block CRC</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The number of bit mismatches between the decoded transport block and original:&quot;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">decodedTxBlock</span><span class="o">-</span><span class="n">txBlock</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<br/></pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
The number of bit mismatches between the decoded transport block and original: 0
</pre></div></div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, InterDigital, Inc. All Rights Reserved.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>