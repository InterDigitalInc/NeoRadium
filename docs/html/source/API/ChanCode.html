

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Channel Coding &mdash; NeoRadium 0.4.0 Documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/neoradium.css?v=45ad03f8" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=6c02275b"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="HARQ" href="Harq.html" />
    <link rel="prev" title="Physical Channels" href="PhyChannels.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            NeoRadium 0.4.0
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">What is NeoRadium?</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Playground/Playground.html">Playground</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Carrier.html">Carriers and Bandwidth Parts</a></li>
<li class="toctree-l1"><a class="reference internal" href="Grid.html">Resource Grid</a></li>
<li class="toctree-l1"><a class="reference internal" href="Waveform.html">Waveform</a></li>
<li class="toctree-l1"><a class="reference internal" href="Modulation.html">Modulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="RefSig.html">Reference Signals</a></li>
<li class="toctree-l1"><a class="reference internal" href="PhyChannels.html">Physical Channels</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Channel Coding</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#neoradium.chancodebase.ChanCodeBase"><code class="docutils literal notranslate"><span class="pre">ChanCodeBase</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#neoradium.chancodebase.ChanCodeBase.getCrc"><code class="docutils literal notranslate"><span class="pre">ChanCodeBase.getCrc()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#neoradium.chancodebase.ChanCodeBase.checkCrc"><code class="docutils literal notranslate"><span class="pre">ChanCodeBase.checkCrc()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#neoradium.chancodebase.ChanCodeBase.appendCrc"><code class="docutils literal notranslate"><span class="pre">ChanCodeBase.appendCrc()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-neoradium.ldpc">LDPC</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#neoradium.ldpc.LdpcBase"><code class="docutils literal notranslate"><span class="pre">LdpcBase</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#neoradium.ldpc.LdpcBase.isValidCodedBlock"><code class="docutils literal notranslate"><span class="pre">LdpcBase.isValidCodedBlock()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#neoradium.ldpc.LdpcEncoder"><code class="docutils literal notranslate"><span class="pre">LdpcEncoder</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#neoradium.ldpc.LdpcEncoder.print"><code class="docutils literal notranslate"><span class="pre">LdpcEncoder.print()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#neoradium.ldpc.LdpcEncoder.doSegmentation"><code class="docutils literal notranslate"><span class="pre">LdpcEncoder.doSegmentation()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#neoradium.ldpc.LdpcEncoder.encode"><code class="docutils literal notranslate"><span class="pre">LdpcEncoder.encode()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#neoradium.ldpc.LdpcEncoder.rateMatch"><code class="docutils literal notranslate"><span class="pre">LdpcEncoder.rateMatch()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#neoradium.ldpc.LdpcEncoder.getRateMatchedCodeBlocks"><code class="docutils literal notranslate"><span class="pre">LdpcEncoder.getRateMatchedCodeBlocks()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#neoradium.ldpc.LdpcEncoder.getDecoder"><code class="docutils literal notranslate"><span class="pre">LdpcEncoder.getDecoder()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#neoradium.ldpc.LdpcDecoder"><code class="docutils literal notranslate"><span class="pre">LdpcDecoder</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#neoradium.ldpc.LdpcDecoder.print"><code class="docutils literal notranslate"><span class="pre">LdpcDecoder.print()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#neoradium.ldpc.LdpcDecoder.recoverRate"><code class="docutils literal notranslate"><span class="pre">LdpcDecoder.recoverRate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#neoradium.ldpc.LdpcDecoder.decode"><code class="docutils literal notranslate"><span class="pre">LdpcDecoder.decode()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#neoradium.ldpc.LdpcDecoder.checkCrcAndMerge"><code class="docutils literal notranslate"><span class="pre">LdpcDecoder.checkCrcAndMerge()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-neoradium.polar">Polar Coding</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#neoradium.polar.PolarBase"><code class="docutils literal notranslate"><span class="pre">PolarBase</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#neoradium.polar.PolarBase.setIoSizes"><code class="docutils literal notranslate"><span class="pre">PolarBase.setIoSizes()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#neoradium.polar.PolarEncoder"><code class="docutils literal notranslate"><span class="pre">PolarEncoder</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#neoradium.polar.PolarEncoder.print"><code class="docutils literal notranslate"><span class="pre">PolarEncoder.print()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#neoradium.polar.PolarEncoder.doSegmentation"><code class="docutils literal notranslate"><span class="pre">PolarEncoder.doSegmentation()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#neoradium.polar.PolarEncoder.encode"><code class="docutils literal notranslate"><span class="pre">PolarEncoder.encode()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#neoradium.polar.PolarEncoder.rateMatch"><code class="docutils literal notranslate"><span class="pre">PolarEncoder.rateMatch()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#neoradium.polar.PolarDecoder"><code class="docutils literal notranslate"><span class="pre">PolarDecoder</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#neoradium.polar.PolarDecoder.print"><code class="docutils literal notranslate"><span class="pre">PolarDecoder.print()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#neoradium.polar.PolarDecoder.recoverRate"><code class="docutils literal notranslate"><span class="pre">PolarDecoder.recoverRate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#neoradium.polar.PolarDecoder.decode"><code class="docutils literal notranslate"><span class="pre">PolarDecoder.decode()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Harq.html">HARQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="Antenna.html">Antenna</a></li>
<li class="toctree-l1"><a class="reference internal" href="Channels.html">Channel Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="Random.html">Random Number Generator</a></li>
<li class="toctree-l1"><a class="reference internal" href="DeepMIMO.html">DeepMIMO and UE Trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="SnrHelper.html">SnrScheduler</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">NeoRadium 0.4.0</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Channel Coding</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/source/API/ChanCode.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-neoradium.chancodebase">
<span id="channel-coding"></span><h1>Channel Coding<a class="headerlink" href="#module-neoradium.chancodebase" title="Link to this heading"></a></h1>
<p>The module <code class="docutils literal notranslate"><span class="pre">chancodebase.py</span></code> implements the base class <a class="reference internal" href="#neoradium.chancodebase.ChanCodeBase" title="neoradium.chancodebase.ChanCodeBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChanCodeBase</span></code></a> for all <strong>NeoRadium</strong>’s channel
coding classes. It encapsulates some basic functionality such as creating, appending, and checking various types of
CRC based on <strong>3GPP TS 38.212</strong>.</p>
<p>Here is the hierarchy of current channel coding classes in <strong>NeoRadium</strong>:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#neoradium.chancodebase.ChanCodeBase" title="neoradium.chancodebase.ChanCodeBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChanCodeBase</span></code></a> (The base class for all channel coding)</p>
<ul>
<li><p><a class="reference internal" href="#neoradium.ldpc.LdpcBase" title="neoradium.ldpc.LdpcBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">LdpcBase</span></code></a> (The base class for Low-Density Parity Check coding)</p>
<ul>
<li><p><a class="reference internal" href="#neoradium.ldpc.LdpcEncoder" title="neoradium.ldpc.LdpcEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">LdpcEncoder</span></code></a></p></li>
<li><p><a class="reference internal" href="#neoradium.ldpc.LdpcDecoder" title="neoradium.ldpc.LdpcDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">LdpcDecoder</span></code></a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#neoradium.polar.PolarBase" title="neoradium.polar.PolarBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolarBase</span></code></a> (The base class for Polar coding)</p>
<ul>
<li><p><a class="reference internal" href="#neoradium.polar.PolarEncoder" title="neoradium.polar.PolarEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolarEncoder</span></code></a></p></li>
<li><p><a class="reference internal" href="#neoradium.polar.PolarDecoder" title="neoradium.polar.PolarDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolarDecoder</span></code></a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="py class">
<dt class="sig sig-object py" id="neoradium.chancodebase.ChanCodeBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">neoradium.chancodebase.</span></span><span class="sig-name descname"><span class="pre">ChanCodeBase</span></span><a class="headerlink" href="#neoradium.chancodebase.ChanCodeBase" title="Link to this definition"></a></dt>
<dd><p>This is the base class for all channel coding classes in <strong>NeoRadium</strong>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="neoradium.chancodebase.ChanCodeBase.getCrc">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">getCrc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#neoradium.chancodebase.ChanCodeBase.getCrc" title="Link to this definition"></a></dt>
<dd><p>Calculates and returns the CRC based on the bitstream <code class="docutils literal notranslate"><span class="pre">bits</span></code> and the generator polynomial specified by
<code class="docutils literal notranslate"><span class="pre">poly</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bits</strong> (<em>NumPy array</em>) – A 1D or 2D NumPy array of bits. If it is a 1D NumPy array, the CRC bits are calculated for the given
bitstream and a 1D NumPy array containing the CRC bits is returned. If <code class="docutils literal notranslate"><span class="pre">bits</span></code> is an <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">x</span> <span class="pre">L</span></code> NumPy
array, it is assumed that we have <code class="docutils literal notranslate"><span class="pre">N</span></code> bitstreams of length <code class="docutils literal notranslate"><span class="pre">L</span></code>. In this case the CRC bits are
calculated for each one of <code class="docutils literal notranslate"><span class="pre">N</span></code> bitstreams and an <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">x</span> <span class="pre">C</span></code> NumPy array is returned where <code class="docutils literal notranslate"><span class="pre">C</span></code> is
the CRC length.</p></li>
<li><p><strong>poly</strong> (<em>str</em>) – <p>The string specifying the generator polynomial. The following generator polynomials are supported.</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>The value of <code class="docutils literal notranslate"><span class="pre">poly</span></code></p></th>
<th class="head"><p>Generator polynomial</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>’6’</p></td>
<td><p>1100001</p></td>
</tr>
<tr class="row-odd"><td><p>’11’</p></td>
<td><p>111000100001</p></td>
</tr>
<tr class="row-even"><td><p>’16’</p></td>
<td><p>10001000000100001</p></td>
</tr>
<tr class="row-odd"><td><p>’24A’</p></td>
<td><p>1100001100100110011111011</p></td>
</tr>
<tr class="row-even"><td><p>’24B’</p></td>
<td><p>1100000000000000001100011</p></td>
</tr>
<tr class="row-odd"><td><p>’24C’</p></td>
<td><p>1101100101011000100010111</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>For more details please refer to <strong>3GPP TS 38.212, Section 5.1</strong>.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If <code class="docutils literal notranslate"><span class="pre">bits</span></code> is a 1D NumPy array, the CRC bits are returned in a 1D NumPy array. If <code class="docutils literal notranslate"><span class="pre">bits</span></code> is an
<code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">x</span> <span class="pre">L</span></code> NumPy array, the CRC bits of <code class="docutils literal notranslate"><span class="pre">N</span></code> bitstreams are returned in an <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">x</span> <span class="pre">C</span></code> NumPy array where
<code class="docutils literal notranslate"><span class="pre">C</span></code> is the CRC length.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>NumPy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="neoradium.chancodebase.ChanCodeBase.checkCrc">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">checkCrc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#neoradium.chancodebase.ChanCodeBase.checkCrc" title="Link to this definition"></a></dt>
<dd><p>Checks the CRC bits at the end of the bitstream <code class="docutils literal notranslate"><span class="pre">bits</span></code> and returns <cite>True</cite> if the CRC is correct (matched)
and <cite>False</cite> if it is not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bits</strong> (<em>NumPy array</em>) – A 1D or 2D NumPy array of bits. If it is a 1D NumPy array, the CRC bits are checked for the given
bitstream and a boolean value is returned. If <code class="docutils literal notranslate"><span class="pre">bits</span></code> is an <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">x</span> <span class="pre">L</span></code> NumPy array, it is assumed that
we have <code class="docutils literal notranslate"><span class="pre">N</span></code> bitstreams of length <code class="docutils literal notranslate"><span class="pre">L</span></code>. In this case the CRC bits are checked for each one of <code class="docutils literal notranslate"><span class="pre">N</span></code>
bitstreams and a boolean NumPy array of length <code class="docutils literal notranslate"><span class="pre">N</span></code> is returned specifying the results of CRC check
for each bitstream.</p></li>
<li><p><strong>poly</strong> (<em>str</em>) – The string specifying the generator polynomial. See the <a class="reference internal" href="#neoradium.chancodebase.ChanCodeBase.getCrc" title="neoradium.chancodebase.ChanCodeBase.getCrc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getCrc()</span></code></a> method above for a list of
generator polynomials.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If <code class="docutils literal notranslate"><span class="pre">bits</span></code> is a 1D NumPy array, the CRC check result is returned as a boolean value. If <code class="docutils literal notranslate"><span class="pre">bits</span></code> is an
<code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">x</span> <span class="pre">L</span></code> NumPy array, the CRC check results of <code class="docutils literal notranslate"><span class="pre">N</span></code> bitstreams are returned in a boolean NumPy array
of length <code class="docutils literal notranslate"><span class="pre">N</span></code>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>boolean or NumPy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="neoradium.chancodebase.ChanCodeBase.appendCrc">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">appendCrc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#neoradium.chancodebase.ChanCodeBase.appendCrc" title="Link to this definition"></a></dt>
<dd><p>Calculates the CRC bits for the bitstream <code class="docutils literal notranslate"><span class="pre">bits</span></code>, appends them to the end of the bitstream, and returns the
new bitstream containing the original bitstream with CRC bits at the end.</p>
<p>This function calls the <a class="reference internal" href="#neoradium.chancodebase.ChanCodeBase.getCrc" title="neoradium.chancodebase.ChanCodeBase.getCrc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getCrc()</span></code></a> method to get the CRC bits and then appends them to the end of
<code class="docutils literal notranslate"><span class="pre">bits</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bits</strong> (<em>NumPy array</em>) – A 1D or 2D NumPy array of bits. If it is a 1D NumPy array, the CRC bits are calculated for the given
bitstream and a 1D NumPy array containing the original bitstream and the CRC bits is returned. If
<code class="docutils literal notranslate"><span class="pre">bits</span></code> is an <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">x</span> <span class="pre">L</span></code> NumPy array, it is assumed that we have <code class="docutils literal notranslate"><span class="pre">N</span></code> bitstreams of length <code class="docutils literal notranslate"><span class="pre">L</span></code>. In
this case the CRC bits are calculated and appended to the end of each one of <code class="docutils literal notranslate"><span class="pre">N</span></code> bitstreams and an
<code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">x</span> <span class="pre">M</span></code> NumPy array is returned where <code class="docutils literal notranslate"><span class="pre">M=L+C</span></code> and <code class="docutils literal notranslate"><span class="pre">C</span></code> is the CRC length.</p></li>
<li><p><strong>poly</strong> (<em>str</em>) – The string specifying the generator polynomial. See the <a class="reference internal" href="#neoradium.chancodebase.ChanCodeBase.getCrc" title="neoradium.chancodebase.ChanCodeBase.getCrc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getCrc()</span></code></a> method above for a list of
generator polynomials.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If <code class="docutils literal notranslate"><span class="pre">bits</span></code> is a 1D NumPy array, the new bitstream with CRC appended to the end is returned in a 1D NumPy
array. If <code class="docutils literal notranslate"><span class="pre">bits</span></code> is an <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">x</span> <span class="pre">L</span></code> NumPy array, the CRC bits for each one of <code class="docutils literal notranslate"><span class="pre">N</span></code> bitstreams are appended
to the end and an <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">x</span> <span class="pre">M</span></code> NumPy array is returned where <code class="docutils literal notranslate"><span class="pre">M=L+C</span></code> and <code class="docutils literal notranslate"><span class="pre">C</span></code> is the CRC length.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>NumPy array</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<hr class="docutils" />
<section id="module-neoradium.ldpc">
<span id="ldpc"></span><h2>LDPC<a class="headerlink" href="#module-neoradium.ldpc" title="Link to this heading"></a></h2>
<p>The module <code class="docutils literal notranslate"><span class="pre">ldpc.py</span></code> contains the API used for
<a class="reference external" href="https://en.wikipedia.org/wiki/Low-density_parity-check_code">Low-Density Parity Check (LDPC)</a> encoding and
decoding. It implements the class <a class="reference internal" href="#neoradium.ldpc.LdpcBase" title="neoradium.ldpc.LdpcBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">LdpcBase</span></code></a>, which is the base class for LDPC coding and is derived
from the <a class="reference internal" href="#neoradium.chancodebase.ChanCodeBase" title="neoradium.chancodebase.ChanCodeBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChanCodeBase</span></code></a> class. It also implements the classes <a class="reference internal" href="#neoradium.ldpc.LdpcEncoder" title="neoradium.ldpc.LdpcEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">LdpcEncoder</span></code></a>
and <a class="reference internal" href="#neoradium.ldpc.LdpcDecoder" title="neoradium.ldpc.LdpcDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">LdpcDecoder</span></code></a> both of which are derived from <a class="reference internal" href="#neoradium.ldpc.LdpcBase" title="neoradium.ldpc.LdpcBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">LdpcBase</span></code></a>.</p>
<p>This implementation is based on <strong>3GPP TS 38.212</strong>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="neoradium.ldpc.LdpcBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">neoradium.ldpc.</span></span><span class="sig-name descname"><span class="pre">LdpcBase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">baseGraphNo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modulation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'QPSK'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">txLayers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nRef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#neoradium.ldpc.LdpcBase" title="Link to this definition"></a></dt>
<dd><p>This is the base class for LDPC coding. Both <a class="reference internal" href="#neoradium.ldpc.LdpcEncoder" title="neoradium.ldpc.LdpcEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">LdpcEncoder</span></code></a> and <a class="reference internal" href="#neoradium.ldpc.LdpcDecoder" title="neoradium.ldpc.LdpcDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">LdpcDecoder</span></code></a> classes are
derived from this class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>baseGraphNo</strong> (<em>int</em>) – The base graph used by the LDPC encoder/decoder. It can be either 1 or 2. The choice of base graph
determines the maximum code block size (8448 bits for base graph 1 and 3840 bits for base graph 2). The
base graphs are defined as <span class="math notranslate nohighlight">\(H_{BG}\)</span> in <strong>3GPP TS 38.212, Tables 5.3.2-2 and 5.3.2-3</strong>.</p></li>
<li><p><strong>modulation</strong> (<em>str</em>) – <p>The modulation scheme used by the physical channel based on table 7.3.1.2-1 in <strong>3GPP TR 38.211</strong>. Here
is a list of supported Modulation Schemes:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Modulation Scheme</p></th>
<th class="head"><p>Modulation Order (<code class="docutils literal notranslate"><span class="pre">qm</span></code>)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>BPSK</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>QPSK</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>16QAM</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-odd"><td><p>64QAM</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-even"><td><p>256QAM</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-odd"><td><p>1024QAM</p></td>
<td><p>10</p></td>
</tr>
</tbody>
</table>
</p></li>
<li><p><strong>txLayers</strong> (<em>int</em>) – The number of transmission layers in the physical channel using this LDPC encoder/decoder.</p></li>
<li><p><strong>nRef</strong> (<em>int</em>) – This is used for Low-Buffer Rate Matching (LBRM). This is the value <span class="math notranslate nohighlight">\(N_{ref}\)</span> as explained in
<strong>3GPP TS 38.212, Section 5.4.2.1</strong>.</p></li>
</ul>
</dd>
</dl>
<p><strong>Other Properties:</strong></p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">baseGraph<span class="colon">:</span></dt>
<dd class="field-odd"><p>The base graph matrix defined as <span class="math notranslate nohighlight">\(H_{BG}\)</span> in <strong>3GPP 3GPP TS 38.212, Tables 5.3.2-2
and 5.3.2-3</strong>.</p>
</dd>
<dt class="field-even">maxCodeBlockSize<span class="colon">:</span></dt>
<dd class="field-even"><p>The maximum code block size. It is set to 8448 for <code class="docutils literal notranslate"><span class="pre">baseGraphNo=1</span></code>, and 3840 for
<code class="docutils literal notranslate"><span class="pre">baseGraphNo=2</span></code>. This is <span class="math notranslate nohighlight">\(K_{cb}\)</span> in <strong>3GPP TS 38.212, Section 5.2.2</strong>.</p>
</dd>
<dt class="field-odd">txBlockSize<span class="colon">:</span></dt>
<dd class="field-odd"><p>Transport block size. The length of the transport block in bits. The function
<a class="reference internal" href="PhyChannels.html#neoradium.pdsch.PDSCH.getTxBlockSize" title="neoradium.pdsch.PDSCH.getTxBlockSize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getTxBlockSize()</span></code></a> could be used to obtain the size of the transport
block. Note that a transport block is first appended with a 24-bit CRC. The value <code class="docutils literal notranslate"><span class="pre">txBlockSize</span></code>
includes the 24-bit CRC. This is <span class="math notranslate nohighlight">\(B\)</span> in <strong>3GPP TS 38.212, Section 5.2.2</strong>.</p>
</dd>
<dt class="field-even">numCodeBlocks<span class="colon">:</span></dt>
<dd class="field-even"><p>The number of code blocks. This is a positive integer, determined based on
<code class="docutils literal notranslate"><span class="pre">maxCodeBlockSize</span></code> and <code class="docutils literal notranslate"><span class="pre">txBlockSize</span></code>. This is <span class="math notranslate nohighlight">\(C\)</span> in <strong>3GPP TS 38.212, Section 5.2.2</strong>.</p>
</dd>
<dt class="field-odd">codeBlockSize<span class="colon">:</span></dt>
<dd class="field-odd"><p>The code block size. This is <span class="math notranslate nohighlight">\(K\)</span> in <strong>3GPP TS 38.212, Section 5.2.2</strong>.</p>
</dd>
<dt class="field-even">liftingSize<span class="colon">:</span></dt>
<dd class="field-even"><p>The <em>lifting size</em> which is used to create a parity-check matrix from the base graph. This
value is extracted from <strong>3GPP TS 38.212, Table 5.3.2-1</strong>. This is <span class="math notranslate nohighlight">\(Z_c\)</span> in <strong>3GPP TS 38.212,
Section 5.2.2</strong>.</p>
</dd>
<dt class="field-odd">setIndex<span class="colon">:</span></dt>
<dd class="field-odd"><p>The <em>Set index</em> (<span class="math notranslate nohighlight">\(i_{LS}\)</span>) in <strong>3GPP TS 38.212, Table 5.3.2-1</strong>.</p>
</dd>
</dl>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All of these properties are initialized only <em>after</em> a call to <a class="reference internal" href="#neoradium.ldpc.LdpcEncoder.doSegmentation" title="neoradium.ldpc.LdpcEncoder.doSegmentation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">doSegmentation()</span></code></a>
or <a class="reference internal" href="#neoradium.ldpc.LdpcEncoder.getRateMatchedCodeBlocks" title="neoradium.ldpc.LdpcEncoder.getRateMatchedCodeBlocks"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getRateMatchedCodeBlocks()</span></code></a> methods of <a class="reference internal" href="#neoradium.ldpc.LdpcEncoder" title="neoradium.ldpc.LdpcEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">LdpcEncoder</span></code></a> class or the
<a class="reference internal" href="#neoradium.ldpc.LdpcDecoder.recoverRate" title="neoradium.ldpc.LdpcDecoder.recoverRate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recoverRate()</span></code></a> method of <a class="reference internal" href="#neoradium.ldpc.LdpcDecoder" title="neoradium.ldpc.LdpcDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">LdpcDecoder</span></code></a> class.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="neoradium.ldpc.LdpcBase.isValidCodedBlock">
<span class="sig-name descname"><span class="pre">isValidCodedBlock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">codedBlock</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#neoradium.ldpc.LdpcBase.isValidCodedBlock" title="Link to this definition"></a></dt>
<dd><p>Checks whether the given <code class="docutils literal notranslate"><span class="pre">codedBlock</span></code> is a valid LDPC coded bitstream.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>codedBlock</strong> (<em>NumPy array</em>) – A NumPy array of bits representing the coded block. The length of <code class="docutils literal notranslate"><span class="pre">codedBlock</span></code> must be a multiple of
the property <code class="docutils literal notranslate"><span class="pre">liftingSize</span></code> (<span class="math notranslate nohighlight">\(Z_c\)</span>).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>True</cite> is returned if this is a valid LDPC coded block. Otherwise, this function returns <cite>False</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>boolean</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="neoradium.ldpc.LdpcEncoder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">neoradium.ldpc.</span></span><span class="sig-name descname"><span class="pre">LdpcEncoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">baseGraphNo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modulation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'QPSK'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">txLayers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nRef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targetRate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.4384765625</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#neoradium.ldpc.LdpcEncoder" title="Link to this definition"></a></dt>
<dd><p>This is the <a class="reference external" href="https://en.wikipedia.org/wiki/Low-density_parity-check_code">Low-Density Parity Check (LDPC)</a>
encoder class. It is derived from the <a class="reference internal" href="#neoradium.ldpc.LdpcBase" title="neoradium.ldpc.LdpcBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">LdpcBase</span></code></a> class and performs the following tasks:</p>
<ul class="simple">
<li><p>Code block segmentation based on <strong>3GPP TS 38.212, Section 5.2.2</strong></p></li>
<li><p>LDPC encoding based on <strong>3GPP TS 38.212, Section 5.3.2</strong></p></li>
<li><p>Rate Matching with bit selection and interleaving based on <strong>3GPP TS 38.212, Section 5.4.2</strong></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>baseGraphNo</strong> (<em>int</em>) – The base graph used by this LDPC encoder. It can be either 1 or 2. In NR, base graph 1 is designed for
code rates from 1/3 to 22/24 (approximately 0.33-0.92) and base graph 2 from 1/5 to 5/6 (approximately
0.2-0.83). The choice between base graph 1 or 2 is based on the transport block size and the targeted
code rate (<code class="docutils literal notranslate"><span class="pre">targetRate</span></code>). The choice of base graph then determines the maximum code block size (8448
bits for base graph 1 and 3840 bits for base graph 2). The base graphs are defined as <span class="math notranslate nohighlight">\(H_{BG}\)</span> in
<strong>3GPP 3GPP TS 38.212, Tables 5.3.2-2 and 5.3.2-3</strong>.</p></li>
<li><p><strong>modulation</strong> (<em>str</em>) – <p>The modulation scheme used by the physical channel based on table 7.3.1.2-1 in <strong>3GPP TR 38.211</strong>. Here
is a list of supported Modulation Schemes:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Modulation Scheme</p></th>
<th class="head"><p>Modulation Order (<code class="docutils literal notranslate"><span class="pre">qm</span></code>)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>BPSK</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>QPSK</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>16QAM</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-odd"><td><p>64QAM</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-even"><td><p>256QAM</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-odd"><td><p>1024QAM</p></td>
<td><p>10</p></td>
</tr>
</tbody>
</table>
</p></li>
<li><p><strong>txLayers</strong> (<em>int</em>) – The number of transmission layers in the physical channel using this LDPC encoder.</p></li>
<li><p><strong>nRef</strong> (<em>int</em>) – This is used for Low-Buffer Rate Matching (LBRM). Please refer to <strong>3GPP TS 38.212, Section 5.4.2.1</strong>
for more details.</p></li>
<li><p><strong>targetRate</strong> (<em>float</em>) – The desired code rate which is the ratio of the data bits to the total number of
bits transmitted (including the LDPC redundancy bits).</p></li>
</ul>
</dd>
</dl>
<p>Please refer to the <a class="reference internal" href="#neoradium.ldpc.LdpcBase" title="neoradium.ldpc.LdpcBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">LdpcBase</span></code></a> class for a list of properties inherited from the base class.</p>
<dl class="py method">
<dt class="sig sig-object py" id="neoradium.ldpc.LdpcEncoder.print">
<span class="sig-name descname"><span class="pre">print</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">getStr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#neoradium.ldpc.LdpcEncoder.print" title="Link to this definition"></a></dt>
<dd><p>Prints the properties of this <a class="reference internal" href="#neoradium.ldpc.LdpcEncoder" title="neoradium.ldpc.LdpcEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">LdpcEncoder</span></code></a> object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indent</strong> (<em>int</em>) – The number of indentation characters.</p></li>
<li><p><strong>title</strong> (<em>str</em>) – If specified, it is used as a title for the printed information.</p></li>
<li><p><strong>getStr</strong> (<em>Boolean</em>) – If <cite>True</cite>, returns a text string instead of printing it.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the <code class="docutils literal notranslate"><span class="pre">getStr</span></code> parameter is <cite>True</cite>, then this function returns the information in a text string.
Otherwise, nothing is returned.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None or str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="neoradium.ldpc.LdpcEncoder.doSegmentation">
<span class="sig-name descname"><span class="pre">doSegmentation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">txBlock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fillerBit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#neoradium.ldpc.LdpcEncoder.doSegmentation" title="Link to this definition"></a></dt>
<dd><p>The first step in LDPC encoding process is breaking down the transport block into smaller more manageable
code blocks. This function receives a transport block <code class="docutils literal notranslate"><span class="pre">txBlock</span></code>, performs segmentation based on <strong>3GPP
TS 38.212, Section 5.2.2</strong>, and outputs a 2D <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">x</span> <span class="pre">K</span></code> NumPy array containing <code class="docutils literal notranslate"><span class="pre">C</span></code> code blocks of length <code class="docutils literal notranslate"><span class="pre">K</span></code>.</p>
<figure class="align-center" id="id10" style="width: 600px">
<img alt="../../_images/TxpBlock.jpg" src="../../_images/TxpBlock.jpg" />
<figcaption>
<p><span class="caption-text">Transport Block Segmentation <a class="footnote-reference brackets" href="#id8" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></span><a class="headerlink" href="#id10" title="Link to this image"></a></p>
</figcaption>
</figure>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>txBlock</strong> (<em>NumPy array</em>) – A NumPy array of bits containing the transport block information.</p></li>
<li><p><strong>fillerBit</strong> (<em>int</em>) – <p>This parameter is ignored.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>NeoRadium no longer uses the filler bits in its newer versions. This parameter will be removed
in future releases.</p>
</div>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A 2D <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">x</span> <span class="pre">K</span></code> NumPy array containing <code class="docutils literal notranslate"><span class="pre">C</span></code> code blocks of length
<code class="docutils literal notranslate"><span class="pre">K</span></code>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>NumPy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="neoradium.ldpc.LdpcEncoder.encode">
<span class="sig-name descname"><span class="pre">encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">codeBlocks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">puncture</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#neoradium.ldpc.LdpcEncoder.encode" title="Link to this definition"></a></dt>
<dd><p>This function encodes a set of code blocks and returns a set of LDPC coded blocks based on the procedure
explained in <strong>3GPP TS 38.212, Section 5.3.2</strong>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>codeBlocks</strong> (<em>NumPy array</em>) – A <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">x</span> <span class="pre">K</span></code> NumPy array containing <code class="docutils literal notranslate"><span class="pre">C</span></code> code blocks of length <code class="docutils literal notranslate"><span class="pre">K</span></code> being LDPC-encoded by this function.</p></li>
<li><p><strong>puncture</strong> (<em>Boolean</em>) – By default, the first <span class="math notranslate nohighlight">\(2Z_c\)</span> bits of the code blocks are <em>punctured</em> (removed). If <code class="docutils literal notranslate"><span class="pre">puncture=False</span></code>,
then the first <span class="math notranslate nohighlight">\(2Z_c\)</span> bits are kept in the returned encoded blocks.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">x</span> <span class="pre">N</span></code> NumPy array containing the <code class="docutils literal notranslate"><span class="pre">C</span></code> encoded blocks.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>NumPy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="neoradium.ldpc.LdpcEncoder.rateMatch">
<span class="sig-name descname"><span class="pre">rateMatch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">codedBlocks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">concatCBs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#neoradium.ldpc.LdpcEncoder.rateMatch" title="Link to this definition"></a></dt>
<dd><p>This function receives a set of encoded blocks and returns the rate-matched output based on the
configured code rate. It performs bit selection and interleaving based on <strong>3GPP TS 38.212, Section 5.4.2</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>codedBlocks</strong> (<em>NumPy array</em>) – A <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">x</span> <span class="pre">N</span></code> NumPy array containing <code class="docutils literal notranslate"><span class="pre">C</span></code> encoded code blocks of length <code class="docutils literal notranslate"><span class="pre">N</span></code> being rate-matched by this
function.</p></li>
<li><p><strong>g</strong> (<em>int</em><em> or </em><em>None</em>) – This is the total number of bits available for transmission of the transport block. It is the value
<span class="math notranslate nohighlight">\(G\)</span> in the <em>bit selection</em> process explained in <strong>3GPP TS 38.212, Section 5.4.2.1</strong>. If not
provided (default), it is calculated as <span class="math notranslate nohighlight">\(G=\lceil \frac {B-24} R \rceil\)</span> where <span class="math notranslate nohighlight">\(B\)</span> is the
transport block size and <span class="math notranslate nohighlight">\(R\)</span> is the code rate.</p></li>
<li><p><strong>concatCBs</strong> (<em>Boolean</em>) – If <cite>True</cite> (Default), the rate-matched coded blocks are concatenated and a single array of bits is
returned. Otherwise, a list of NumPy arrays is returned and each element in the list is the bit array
corresponding to each coded block.</p></li>
<li><p><strong>rv</strong> (<em>int</em>) – The <em>Redundancy Version</em> used with
<a class="reference external" href="https://en.wikipedia.org/wiki/Hybrid_automatic_repeat_request">Hybrid Automatic Repeat Request (HARQ)</a>.
It must be one of 0, 1, 2, or 3. Please refer to <strong>3GPP TS 38.212, Table 5.4.2.1-2</strong> for more details. The
default is 0 which means first transmission.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If <code class="docutils literal notranslate"><span class="pre">concatCBs</span></code> is <cite>True</cite>, a 1-D NumPy array is returned containing the concatenation of all
rate-matched coded blocks. Otherwise, a list of NumPy arrays is returned and each element in the list
is the bit array corresponding to each coded block.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>NumPy array or list of NumPy arrays</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="neoradium.ldpc.LdpcEncoder.getRateMatchedCodeBlocks">
<span class="sig-name descname"><span class="pre">getRateMatchedCodeBlocks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">txBlock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">concatCBs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">addCrc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#neoradium.ldpc.LdpcEncoder.getRateMatchedCodeBlocks" title="Link to this definition"></a></dt>
<dd><p>This function receives a transport block (<code class="docutils literal notranslate"><span class="pre">txBlock</span></code>) and returns the rate-matched output in a single call.
It first appends a 24-bit CRC to the transport block and then uses the functions <a class="reference internal" href="#neoradium.ldpc.LdpcEncoder.doSegmentation" title="neoradium.ldpc.LdpcEncoder.doSegmentation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">doSegmentation()</span></code></a>,
<a class="reference internal" href="#neoradium.ldpc.LdpcEncoder.encode" title="neoradium.ldpc.LdpcEncoder.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code></a>, and <a class="reference internal" href="#neoradium.ldpc.LdpcEncoder.rateMatch" title="neoradium.ldpc.LdpcEncoder.rateMatch"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rateMatch()</span></code></a>, to perform segmentation, encoding, and rate matching.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>txBlock</strong> (<em>NumPy array</em>) – A NumPy array of bits containing the transport block information.</p></li>
<li><p><strong>g</strong> (<em>int</em><em> or </em><em>None</em>) – This is the total number of bits available for transmission of the transport block. It is the value
<span class="math notranslate nohighlight">\(G\)</span> in the <em>bit selection</em> process explained in <strong>3GPP TS 38.212, Section 5.4.2.1</strong>. If not
provided (default), it is calculated as <span class="math notranslate nohighlight">\(G=\lceil \frac {B-24} R \rceil\)</span> where <span class="math notranslate nohighlight">\(B\)</span> is the
transport block size and <span class="math notranslate nohighlight">\(R\)</span> is the code rate.</p></li>
<li><p><strong>concatCBs</strong> (<em>Boolean</em>) – If <cite>True</cite> (Default), the rate-matched coded blocks are concatenated and a single array of bits is
returned. Otherwise, a list of NumPy arrays is returned and each element in the list is the bit array
corresponding to each coded block.</p></li>
<li><p><strong>addCrc</strong> (<em>Boolean</em>) – If <cite>True</cite> a 24-bit CRC is appended to the <code class="docutils literal notranslate"><span class="pre">txBlock</span></code> before the encoding process. Otherwise, it is
assumed that the <code class="docutils literal notranslate"><span class="pre">txBlock</span></code> already includes the 24-bit CRC and therefore a CRC is not appended.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If <code class="docutils literal notranslate"><span class="pre">concatCBs</span></code> is <cite>True</cite>, a 1-D NumPy array is returned containing the concatenation of all
rate-matched coded blocks. Otherwise, a list of NumPy arrays is returned and each element in the list
is the bit array corresponding to each coded block.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>NumPy array or list of NumPy arrays</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="neoradium.ldpc.LdpcEncoder.getDecoder">
<span class="sig-name descname"><span class="pre">getDecoder</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#neoradium.ldpc.LdpcEncoder.getDecoder" title="Link to this definition"></a></dt>
<dd><p>This function creates and returns an <a class="reference internal" href="#neoradium.ldpc.LdpcDecoder" title="neoradium.ldpc.LdpcDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">LdpcDecoder</span></code></a> object based on the configuration of this
<a class="reference internal" href="#neoradium.ldpc.LdpcEncoder" title="neoradium.ldpc.LdpcEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">LdpcEncoder</span></code></a>. It makes it easier to create a decoder object based on the existing encoder object.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>An LDPC decoder object created based on this <a class="reference internal" href="#neoradium.ldpc.LdpcEncoder" title="neoradium.ldpc.LdpcEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">LdpcEncoder</span></code></a>.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#neoradium.ldpc.LdpcDecoder" title="neoradium.ldpc.LdpcDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">LdpcDecoder</span></code></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="neoradium.ldpc.LdpcDecoder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">neoradium.ldpc.</span></span><span class="sig-name descname"><span class="pre">LdpcDecoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">baseGraphNo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modulation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'QPSK'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">txLayers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nRef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#neoradium.ldpc.LdpcDecoder" title="Link to this definition"></a></dt>
<dd><p>This is the <a class="reference external" href="https://en.wikipedia.org/wiki/Low-density_parity-check_code">Low-Density Parity Check (LDPC)</a>
decoder class. It is derived from the <a class="reference internal" href="#neoradium.ldpc.LdpcBase" title="neoradium.ldpc.LdpcBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">LdpcBase</span></code></a> class and performs rate recovery, LDPC decoding, and
code block merging. These are basically the opposite of the encoding tasks rate matching, LDPC encoding, and
segmentation which are performed in reverse order.</p>
<p>The following example shows a typical use case for decoding the received LDPC-coded information into transport
blocks:</p>
<div class="literal-block-wrapper docutils container" id="id11">
<div class="code-block-caption"><span class="caption-text">An example of LDPC decoding</span><a class="headerlink" href="#id11" title="Link to this code"></a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Rate recovery</span>
<span class="c1"># Let&#39;s assume we have:</span>
<span class="c1">#   An LdpcDecoder object (ldpcDecoder)</span>
<span class="c1">#   The LLRs extracted from a received resource grid (llrs)</span>
<span class="c1">#   The transport block size (txBlockSize)</span>
<span class="n">rxCodedBlocks</span> <span class="o">=</span> <span class="n">ldpcDecoder</span><span class="o">.</span><span class="n">recoverRate</span><span class="p">(</span><span class="n">llrs</span><span class="p">,</span> <span class="n">txBlockSize</span><span class="p">)</span>

<span class="c1"># LDPC-Decoding</span>
<span class="n">decodedBlocks</span> <span class="o">=</span> <span class="n">ldpcDecoder</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">rxCodedBlocks</span><span class="p">)</span>

<span class="c1"># CRC-checking and de-segmentation</span>
<span class="n">decodedTxBlockWithCRC</span><span class="p">,</span> <span class="n">crcMatch</span> <span class="o">=</span> <span class="n">ldpcDecoder</span><span class="o">.</span><span class="n">checkCrcAndMerge</span><span class="p">(</span><span class="n">decodedBlocks</span><span class="p">)</span>

<span class="c1"># Checking the CRC of the transport block</span>
<span class="n">txBlockCrcMatch</span> <span class="o">=</span> <span class="n">ldpcDecoder</span><span class="o">.</span><span class="n">checkCrc</span><span class="p">(</span><span class="n">decodedTxBlockWithCRC</span><span class="p">,</span><span class="s1">&#39;24A&#39;</span><span class="p">)</span>

<span class="c1"># Removing the transport block CRC</span>
<span class="n">decodedTxBlock</span> <span class="o">=</span> <span class="n">decodedTxBlockWithCRC</span><span class="p">[:</span><span class="o">-</span><span class="mi">24</span><span class="p">]</span>
</pre></div>
</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>baseGraphNo</strong> (<em>int</em>) – The base graph used by this LDPC decoder. It can be either 1 or 2. In NR, base graph 1 is designed for
code rates from 1/3 to 22/24 (approximately 0.33-0.92) and base graph 2 from 1/5 to 5/6 (approximately
0.2-0.83). The choice between base graph 1 or 2 is based on the transport block size and the targeted
code rate (<code class="docutils literal notranslate"><span class="pre">targetRate</span></code>). The choice of base graph then determines the maximum code block size (8448
bits for base graph 1 and 3840 bits for base graph 2). The base graphs are defined as <span class="math notranslate nohighlight">\(H_{BG}\)</span> in
<strong>3GPP 3GPP TS 38.212, Tables 5.3.2-2 and 5.3.2-3</strong>.</p></li>
<li><p><strong>modulation</strong> (<em>str</em>) – <p>The modulation scheme used by the physical channel based on table 7.3.1.2-1 in <strong>3GPP TR 38.211</strong>. Here
is a list of supported Modulation Schemes:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Modulation Scheme</p></th>
<th class="head"><p>Modulation Order (<code class="docutils literal notranslate"><span class="pre">qm</span></code>)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>BPSK</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>QPSK</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>16QAM</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-odd"><td><p>64QAM</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-even"><td><p>256QAM</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-odd"><td><p>1024QAM</p></td>
<td><p>10</p></td>
</tr>
</tbody>
</table>
</p></li>
<li><p><strong>txLayers</strong> (<em>int</em>) – The number of transmission layers in the physical channel using this LDPC decoder.</p></li>
<li><p><strong>nRef</strong> (<em>int</em>) – This is used for Low-Buffer Rate Matching (LBRM). Please refer to <strong>3GPP TS 38.212, Section 5.4.2.1</strong>
for more details.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For a pair of <a class="reference internal" href="#neoradium.ldpc.LdpcEncoder" title="neoradium.ldpc.LdpcEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">LdpcEncoder</span></code></a>/<a class="reference internal" href="#neoradium.ldpc.LdpcDecoder" title="neoradium.ldpc.LdpcDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">LdpcDecoder</span></code></a> objects to work properly, all of
the above parameters used to configure them should match.</p>
</div>
<p>Please refer to the <a class="reference internal" href="#neoradium.ldpc.LdpcBase" title="neoradium.ldpc.LdpcBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">LdpcBase</span></code></a> class for a list of properties inherited from the base class.</p>
<dl class="py method">
<dt class="sig sig-object py" id="neoradium.ldpc.LdpcDecoder.print">
<span class="sig-name descname"><span class="pre">print</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">getStr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#neoradium.ldpc.LdpcDecoder.print" title="Link to this definition"></a></dt>
<dd><p>Prints the properties of this <a class="reference internal" href="#neoradium.ldpc.LdpcDecoder" title="neoradium.ldpc.LdpcDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">LdpcDecoder</span></code></a> object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indent</strong> (<em>int</em>) – The number of indentation characters.</p></li>
<li><p><strong>title</strong> (<em>str</em>) – If specified, it is used as a title for the printed information.</p></li>
<li><p><strong>getStr</strong> (<em>Boolean</em>) – If <cite>True</cite>, returns a text string instead of printing it.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the <code class="docutils literal notranslate"><span class="pre">getStr</span></code> parameter is <cite>True</cite>, then this function returns the information in a text string.
Otherwise, nothing is returned.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None or str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="neoradium.ldpc.LdpcDecoder.recoverRate">
<span class="sig-name descname"><span class="pre">recoverRate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rxBlock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">txBlockSize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">harq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#neoradium.ldpc.LdpcDecoder.recoverRate" title="Link to this definition"></a></dt>
<dd><p>This function receives an array of Log-Likelihood Ratios (LLRs) in <code class="docutils literal notranslate"><span class="pre">rxBlock</span></code>, and the transport block
size <code class="docutils literal notranslate"><span class="pre">txBlockSize</span></code>, and returns a set of rate-recovered LLRs for each code block that is ready for LDPC
decoding. This function does the exact opposite of the <a class="reference internal" href="#neoradium.ldpc.LdpcEncoder" title="neoradium.ldpc.LdpcEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">LdpcEncoder</span></code></a>’s <code class="xref py py-meth docutils literal notranslate"><span class="pre">rateMatch()</span></code>
method. Note that while the <code class="xref py py-meth docutils literal notranslate"><span class="pre">rateMatch()</span></code> works with bits, this method works on LLRs.</p>
<p>The LLRs are usually obtained by performing demodulation process. The method
<a class="reference internal" href="PhyChannels.html#neoradium.pdsch.PDSCH.getLLRsFromGrid" title="neoradium.pdsch.PDSCH.getLLRsFromGrid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getLLRsFromGrid()</span></code></a> of the <a class="reference internal" href="PhyChannels.html#neoradium.pdsch.PDSCH" title="neoradium.pdsch.PDSCH"><code class="xref py py-class docutils literal notranslate"><span class="pre">PDSCH</span></code></a> for example
can be used to get LLRs from a received resource grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rxBlock</strong> (<em>NumPy array</em>) – A NumPy array of Log-Likelihood Ratios (LLRs) obtained as a result of demodulation process. Each element
is a real LLR value corresponding to each received bit. The larger the LLR value, the more likely it is
for that bit to be a <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p></li>
<li><p><strong>txBlockSize</strong> (<em>int</em>) – The transport block size. This is the number of bits in a transport block (Not including the 24-bit CRC
that is appended to the transport block). For example, in the case of PDSCH communication, this value
can be obtained using the method <a class="reference internal" href="PhyChannels.html#neoradium.pdsch.PDSCH.getTxBlockSize" title="neoradium.pdsch.PDSCH.getTxBlockSize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getTxBlockSize()</span></code></a> of the
<a class="reference internal" href="PhyChannels.html#neoradium.pdsch.PDSCH" title="neoradium.pdsch.PDSCH"><code class="xref py py-class docutils literal notranslate"><span class="pre">PDSCH</span></code></a> class.</p></li>
<li><p><strong>harq</strong> (<a class="reference internal" href="Harq.html#neoradium.harq.HarqCW" title="neoradium.harq.HarqCW"><code class="xref py py-class docutils literal notranslate"><span class="pre">HarqCW</span></code></a>) – The <a class="reference internal" href="Harq.html#neoradium.harq.HarqCW" title="neoradium.harq.HarqCW"><code class="xref py py-class docutils literal notranslate"><span class="pre">HarqCW</span></code></a> object handling retransmissions for each codeword. If specified,
this method uses this object to obtain the ‘Redundancy Version’ and the circular buffer of the previous
transmission of the same transport block.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">x</span> <span class="pre">N</span></code> NumPy array of <code class="docutils literal notranslate"><span class="pre">C</span></code> received coded blocks of length <code class="docutils literal notranslate"><span class="pre">N</span></code> containing the LLR values for
each coded block ready to be LDPC-decoded.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>NumPy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="neoradium.ldpc.LdpcDecoder.decode">
<span class="sig-name descname"><span class="pre">decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rxCodeBlock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numIter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">onlyInfoBits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outputBelief</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#neoradium.ldpc.LdpcDecoder.decode" title="Link to this definition"></a></dt>
<dd><p>This function implements the <em>Layered Belief Propagation</em> algorithm for LDPC-decoding of LLRs into decoded
code blocks. This implementation was inspired mostly by <a class="reference external" href="https://www.youtube.com/playlist?list=PLyqSpQzTE6M81HJ26ZaNv0V3ROBrcv-Kc">LDPC and Polar Codes in 5G Standard</a> set of videos and was written
from scratch to efficiently perform the decoding process.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rxCodeBlock</strong> (<em>NumPy array</em>) – A <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">x</span> <span class="pre">N</span></code> NumPy array of <code class="docutils literal notranslate"><span class="pre">C</span></code> received coded blocks of length <code class="docutils literal notranslate"><span class="pre">N</span></code> containing the LLR values for
each coded block.</p></li>
<li><p><strong>numIter</strong> (<em>int</em>) – The number of iterations in the <em>Layered Belief Propagation</em> decoding algorithm. Larger values in some
cases could result in more accurate decoding while making the whole decoding process slower.</p></li>
<li><p><strong>onlyInfoBits</strong> (<em>Boolean</em>) – If <cite>True</cite> (default), only the information bits are returned. Otherwise, the parity bits are also
included in the returned values together with the information bits.</p></li>
<li><p><strong>outputBelief</strong> (<em>Boolean</em>) – If <cite>True</cite>, the calculated final belief values are returned for each bit which is the LLR for the
decoded bits. Otherwise (default), <em>hard decision</em> is applied to the final belief values and the
decoded bits are returned.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If <code class="docutils literal notranslate"><span class="pre">onlyInfoBits</span></code> is set to <cite>True</cite>, a <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">x</span> <span class="pre">K</span></code> NumPy array of <code class="docutils literal notranslate"><span class="pre">C</span></code> code blocks of length <code class="docutils literal notranslate"><span class="pre">K</span></code> is
returned, where <code class="docutils literal notranslate"><span class="pre">K</span></code> is the <code class="docutils literal notranslate"><span class="pre">codeBlockSize</span></code>. Otherwise, the parity bit information is also included
in the returned NumPy array which makes each code block longer than <code class="docutils literal notranslate"><span class="pre">K</span></code>. The contents of the return
NumPy array can be bits or belief values based on the <code class="docutils literal notranslate"><span class="pre">outputBelief</span></code> parameter.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>NumPy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="neoradium.ldpc.LdpcDecoder.checkCrcAndMerge">
<span class="sig-name descname"><span class="pre">checkCrcAndMerge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rxCodedBlocks</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#neoradium.ldpc.LdpcDecoder.checkCrcAndMerge" title="Link to this definition"></a></dt>
<dd><p>This function performs CRC checking on the each code block, re-assembles the transport block by combining the
code blocks, and returns the transport block together with the results of CRC checks for each code block.</p>
<p>Note that the returned value of this function includes the 24 bits of transport block CRC. The transport
block CRC can be checked using the <a class="reference internal" href="#neoradium.chancodebase.ChanCodeBase.checkCrc" title="neoradium.chancodebase.ChanCodeBase.checkCrc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">checkCrc()</span></code></a> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>rxCodedBlocks</strong> (<em>NumPy array</em>) – A <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">x</span> <span class="pre">K</span></code> NumPy array of <code class="docutils literal notranslate"><span class="pre">C</span></code> code blocks of length <code class="docutils literal notranslate"><span class="pre">K</span></code>. Each code block contains a CRC as its last
24 bits. The <code class="docutils literal notranslate"><span class="pre">rxCodedBlocks</span></code> is usually the returned value of the <a class="reference internal" href="#neoradium.ldpc.LdpcDecoder.decode" title="neoradium.ldpc.LdpcDecoder.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code></a> method explained
above.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>txBlock</strong> (<em>NumPy array of bits</em>) – The NumPy array containing the transport block together with its 24-bit CRC at the end which can be
verified using the <a class="reference internal" href="#neoradium.chancodebase.ChanCodeBase.checkCrc" title="neoradium.chancodebase.ChanCodeBase.checkCrc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">checkCrc()</span></code></a> method.</p></li>
<li><p><strong>crcCheckResults</strong> (<em>NumPy array of booleans</em>) – The boolean NumPy array containing the CRC check results for each code block. To have a valid transport
block, all of the values in this NumPy array must be <cite>True</cite>.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<hr class="docutils" />
<section id="module-neoradium.polar">
<span id="polar-coding"></span><h2>Polar Coding<a class="headerlink" href="#module-neoradium.polar" title="Link to this heading"></a></h2>
<p>The module <code class="docutils literal notranslate"><span class="pre">polar.py</span></code> contains the API used for
<a class="reference external" href="https://en.wikipedia.org/wiki/Polar_code_(coding_theory)">Polar coding</a>. It implements the class
<a class="reference internal" href="#neoradium.polar.PolarBase" title="neoradium.polar.PolarBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolarBase</span></code></a>, which is the base class for other polar coding classes and is derived from the
<a class="reference internal" href="#neoradium.chancodebase.ChanCodeBase" title="neoradium.chancodebase.ChanCodeBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChanCodeBase</span></code></a> class. It also implements the classes <a class="reference internal" href="#neoradium.polar.PolarEncoder" title="neoradium.polar.PolarEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolarEncoder</span></code></a> and
<a class="reference internal" href="#neoradium.polar.PolarDecoder" title="neoradium.polar.PolarDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolarDecoder</span></code></a> both of which are derived from <a class="reference internal" href="#neoradium.polar.PolarBase" title="neoradium.polar.PolarBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolarBase</span></code></a>.</p>
<p>This implementation is based on <strong>3GPP TS 38.212</strong>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="neoradium.polar.PolarBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">neoradium.polar.</span></span><span class="sig-name descname"><span class="pre">PolarBase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">payloadSize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rateMatchedLen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dataType</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#neoradium.polar.PolarBase" title="Link to this definition"></a></dt>
<dd><p>This is the base class for all polar coding classes. Both <a class="reference internal" href="#neoradium.polar.PolarEncoder" title="neoradium.polar.PolarEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolarEncoder</span></code></a> and <a class="reference internal" href="#neoradium.polar.PolarDecoder" title="neoradium.polar.PolarDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolarDecoder</span></code></a>
classes are derived from it. In 5G NR, polar coding is used for the following cases:</p>
<blockquote>
<div><ul class="simple">
<li><p>Downlink Control Information (DCI)</p></li>
<li><p>Uplink Control Information (UCI)</p></li>
<li><p>Physical Broadcast Channel (PBCH)</p></li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>payloadSize</strong> (<em>int</em>) – The size of input bitstream not including the CRC bits. This is the value <span class="math notranslate nohighlight">\(A\)</span> in <strong>3GPP TS 38.212,
Section 5.2.1</strong>.</p></li>
<li><p><strong>rateMatchedLen</strong> (<em>int</em>) – The total length of rate-matched output bitstream. This is the value <span class="math notranslate nohighlight">\(E\)</span> in <strong>3GPP TS 38.212,
Sections 5.3.1 and 5.4.1</strong>.</p></li>
<li><p><strong>dataType</strong> (<em>str</em><em> or </em><em>None</em>) – <p>The type of data using this Polar encoder/decoder. It can be one of the
following:</p>
<dl class="field-list simple">
<dt class="field-odd">”DCI”<span class="colon">:</span></dt>
<dd class="field-odd"><p>Downlink Control Information</p>
</dd>
<dt class="field-even">”UCI”<span class="colon">:</span></dt>
<dd class="field-even"><p>Uplink Control Information</p>
</dd>
<dt class="field-odd">”PBCH”<span class="colon">:</span></dt>
<dd class="field-odd"><p>Physical Broadcast Channel</p>
</dd>
<dt class="field-even">None<span class="colon">:</span></dt>
<dd class="field-even"><p>Customized Polar Coding.</p>
</dd>
</dl>
</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) – <p>A set of optional arguments depending on the <code class="docutils literal notranslate"><span class="pre">dataType</span></code>:</p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">iBIL<span class="colon">:</span></dt>
<dd class="field-odd"><p>Coded bits Interleaving flag. This is a boolean value that indicates whether coded bits
interleaving is enabled (<cite>True</cite>) or disabled (<cite>False</cite>). By default <code class="docutils literal notranslate"><span class="pre">iBIL=False</span></code>. This
is the value <span class="math notranslate nohighlight">\(I_{BIL}\)</span> in <strong>3GPP TS 38.212, Section 5.4.1.3</strong>. This parameter is ignored
if the <code class="docutils literal notranslate"><span class="pre">dataType</span></code> is not <cite>None</cite>. In this case, <code class="docutils literal notranslate"><span class="pre">iBIL</span></code> is set to <cite>True</cite> for
<code class="docutils literal notranslate"><span class="pre">dataType=&quot;UCI&quot;</span></code>, and <cite>False</cite> for <code class="docutils literal notranslate"><span class="pre">dataType=&quot;DCI&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">dataType=&quot;PBCH&quot;</span></code> cases.</p>
</dd>
<dt class="field-even">nMax<span class="colon">:</span></dt>
<dd class="field-even"><p>Max value of <span class="math notranslate nohighlight">\(n\)</span> where <span class="math notranslate nohighlight">\(N=2^n\)</span> is the length of the polar code. By default this
is set to 10 (which means <span class="math notranslate nohighlight">\(N=1024\)</span>. This is the value <span class="math notranslate nohighlight">\(N_{max}\)</span> in <strong>3GPP TS 38.212,
Section 5.3.1.2</strong>. This parameter is ignored if the <code class="docutils literal notranslate"><span class="pre">dataType</span></code> is not <cite>None</cite>. In this case,
<code class="docutils literal notranslate"><span class="pre">nMax=10</span></code> when <code class="docutils literal notranslate"><span class="pre">dataType=&quot;UCI&quot;</span></code>, and <code class="docutils literal notranslate"><span class="pre">nMax=9</span></code> for <code class="docutils literal notranslate"><span class="pre">dataType=&quot;DCI&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">dataType=&quot;PBCH&quot;</span></code>
cases.</p>
</dd>
<dt class="field-odd">iIL<span class="colon">:</span></dt>
<dd class="field-odd"><p>Input Interleaving flag. This is a boolean value that indicates whether input interleaving
is enabled (<cite>True</cite>) or disabled (<cite>False</cite>). By default <code class="docutils literal notranslate"><span class="pre">iIL=False</span></code>. This is the value
<span class="math notranslate nohighlight">\(I_{IL}\)</span> in <strong>3GPP TS 38.212, Section 5.3.1.1</strong>. This parameter is ignored if the
<code class="docutils literal notranslate"><span class="pre">dataType</span></code> is not <cite>None</cite>. In this case, <code class="docutils literal notranslate"><span class="pre">iIL</span></code> is set to <cite>False</cite> for <code class="docutils literal notranslate"><span class="pre">dataType=&quot;UCI&quot;</span></code>,
and <cite>True</cite> for <code class="docutils literal notranslate"><span class="pre">dataType=&quot;DCI&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">dataType=&quot;PBCH&quot;</span></code> cases.</p>
</dd>
<dt class="field-even">nPC<span class="colon">:</span></dt>
<dd class="field-even"><p>Total number of parity-check bits. By default this is set to 0. This is the value <span class="math notranslate nohighlight">\(N_{PC}\)</span>
in <strong>3GPP TS 38.212, Section 5.3.1</strong>. This parameter is ignored if the <code class="docutils literal notranslate"><span class="pre">dataType</span></code> is not
<cite>None</cite>. In this case, <code class="docutils literal notranslate"><span class="pre">nPC=0</span></code> when <code class="docutils literal notranslate"><span class="pre">dataType</span></code> is set to <code class="docutils literal notranslate"><span class="pre">&quot;DCI&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;PBCH&quot;</span></code>. For the
<code class="docutils literal notranslate"><span class="pre">&quot;UCI&quot;</span></code> case, this value may be set to 0 or 3 which is determined based on the procedure
explained in <strong>3GPP TS 38.212, Section 5.3.1.2</strong>.</p>
</dd>
<dt class="field-odd">nPCwm<span class="colon">:</span></dt>
<dd class="field-odd"><p>The number of <em>Low-weight</em>, <em>High-Reliability</em> parity-check bits out of the total parity-check
bits <code class="docutils literal notranslate"><span class="pre">nPC</span></code>. By default this is set to 0. This is the value <span class="math notranslate nohighlight">\(n_{PC}^{wm}\)</span> in <strong>3GPP TS
38.212, Sections 5.3.1.2, 6.3.1.3.1, and 6.3.2.3.1</strong>. This parameter is ignored if the
<code class="docutils literal notranslate"><span class="pre">dataType</span></code> is not <cite>None</cite>. In this case, <code class="docutils literal notranslate"><span class="pre">nPCwm=0</span></code> when <code class="docutils literal notranslate"><span class="pre">dataType</span></code> is set to <code class="docutils literal notranslate"><span class="pre">&quot;DCI&quot;</span></code>
or <code class="docutils literal notranslate"><span class="pre">&quot;PBCH&quot;</span></code>. For the <code class="docutils literal notranslate"><span class="pre">&quot;UCI&quot;</span></code> case, this value may be set to 0 or 1 which is determined based
on the procedure explained in <strong>3GPP TS 38.212, Sections 6.3.1.3.1 and 6.3.2.3.1</strong>.</p>
</dd>
<dt class="field-even">iSeg<span class="colon">:</span></dt>
<dd class="field-even"><p>Segmentation flag. This is a boolean value that indicates whether segmentation is enabled
(<cite>True</cite>) or disabled (<cite>False</cite>). By default <code class="docutils literal notranslate"><span class="pre">iSeg=False</span></code>. This is the value <span class="math notranslate nohighlight">\(I_{seg}\)</span>
in <strong>3GPP TS 38.212, Section 5.2.1</strong>. This parameter is ignored if the <code class="docutils literal notranslate"><span class="pre">dataType</span></code> is not
<cite>None</cite>. In this case, <code class="docutils literal notranslate"><span class="pre">iSeg=False</span></code> when <code class="docutils literal notranslate"><span class="pre">dataType=&quot;DCI&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">dataType=&quot;PBCH&quot;</span></code>. When
<code class="docutils literal notranslate"><span class="pre">dataType=&quot;UCI&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">iSeg</span></code> is set based on the value of <code class="docutils literal notranslate"><span class="pre">payloadSize</span></code>.</p>
</dd>
<dt class="field-odd">crcPoly<span class="colon">:</span></dt>
<dd class="field-odd"><p>The CRC polynomial. This is a string specifying the CRC polynomial or <cite>None</cite>. If
specified, it must be one of the values specified in
<a class="reference internal" href="#neoradium.chancodebase.ChanCodeBase.getCrc" title="neoradium.chancodebase.ChanCodeBase.getCrc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getCrc()</span></code></a> for the <code class="docutils literal notranslate"><span class="pre">poly</span></code> parameter. The default
value is <code class="docutils literal notranslate"><span class="pre">&quot;11&quot;</span></code>. This parameter is ignored if the <code class="docutils literal notranslate"><span class="pre">dataType</span></code> is not <cite>None</cite>. In this case
<code class="docutils literal notranslate"><span class="pre">crcPoly</span></code> is set to <code class="docutils literal notranslate"><span class="pre">&quot;6&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;11&quot;</span></code> depending on <code class="docutils literal notranslate"><span class="pre">payloadSize</span></code> for <code class="docutils literal notranslate"><span class="pre">dataType=&quot;UCI&quot;</span></code>,
and <code class="docutils literal notranslate"><span class="pre">&quot;24C&quot;</span></code> for <code class="docutils literal notranslate"><span class="pre">dataType=&quot;DCI&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">dataType=&quot;PBCH&quot;</span></code> cases.</p>
</dd>
</dl>
</div></blockquote>
</p></li>
</ul>
</dd>
</dl>
<p><strong>Other Properties:</strong></p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">rateMatchedBlockLen<span class="colon">:</span></dt>
<dd class="field-odd"><p>The number of rate-matched bits transmitted for each code block when segmented. This
is the same as <code class="docutils literal notranslate"><span class="pre">rateMatchedLen</span></code> if segmentation is disabled. This is the value <span class="math notranslate nohighlight">\(E_r\)</span> in
<strong>3GPP TS 38.212, Section 5.5</strong>.</p>
</dd>
<dt class="field-even">codeBlockSize<span class="colon">:</span></dt>
<dd class="field-even"><p>The code block size. This is the value <span class="math notranslate nohighlight">\(K\)</span> in <strong>3GPP TS 38.212, Section 5.3.1</strong>
which includes the CRC bits (if any).</p>
</dd>
<dt class="field-odd">polarCodeSize<span class="colon">:</span></dt>
<dd class="field-odd"><p>The polar code size <span class="math notranslate nohighlight">\(N\)</span>. This is always a power of 2.</p>
</dd>
<dt class="field-even">msgBits<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of indices of the message bits in the coded bitstream.</p>
</dd>
<dt class="field-odd">frozenBits<span class="colon">:</span></dt>
<dd class="field-odd"><p>A list of indices of the <em>frozen bits</em> in the coded bitstream.</p>
</dd>
<dt class="field-even">pcBits<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of indices of the parity-check bits in the coded bitstream. This can be empty depending
on <code class="docutils literal notranslate"><span class="pre">nPC</span></code>.</p>
</dd>
<dt class="field-odd">generator<span class="colon">:</span></dt>
<dd class="field-odd"><p>The polar coding <em>generator</em> matrix as a 2-D NumPy array.</p>
</dd>
</dl>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="neoradium.polar.PolarBase.setIoSizes">
<span class="sig-name descname"><span class="pre">setIoSizes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">payloadSize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rateMatchedLen</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#neoradium.polar.PolarBase.setIoSizes" title="Link to this definition"></a></dt>
<dd><p>This function can be called to re-initialize the class properties. When the <code class="docutils literal notranslate"><span class="pre">payloadSize</span></code> or
<code class="docutils literal notranslate"><span class="pre">rateMatchedLen</span></code> parameters change but other properties remain the same, you can either create a new polar
encoder/decoder object or reuse the existing objects and re-initialize them using this method.</p>
<p>Note that if there is no change in the values of <code class="docutils literal notranslate"><span class="pre">payloadSize</span></code> and <code class="docutils literal notranslate"><span class="pre">rateMatchedLen</span></code>, this function
returns without doing anything.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>payloadSize</strong> (<em>int</em>) – The new size of input bitstream not including the CRC bits. This is the value <span class="math notranslate nohighlight">\(A\)</span> in <strong>3GPP
TS 38.212, Section 5.2.1</strong>.</p></li>
<li><p><strong>rateMatchedLen</strong> (<em>int</em>) – The new total length of rate-matched output bitstream. This is the value <span class="math notranslate nohighlight">\(E\)</span> in <strong>3GPP TS 38.212,
Sections 5.3.1 and 5.4.1</strong>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="neoradium.polar.PolarEncoder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">neoradium.polar.</span></span><span class="sig-name descname"><span class="pre">PolarEncoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">payloadSize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rateMatchedLen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dataType</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#neoradium.polar.PolarEncoder" title="Link to this definition"></a></dt>
<dd><p>This class is used to encode a bitstream using
<a class="reference external" href="https://en.wikipedia.org/wiki/Polar_code_(coding_theory)">Polar coding</a>. It is derived from the
<a class="reference internal" href="#neoradium.polar.PolarBase" title="neoradium.polar.PolarBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolarBase</span></code></a> class and performs the following tasks:</p>
<ul class="simple">
<li><p>Segmentation of the transport block based on <strong>3GPP TS 38.212, Section 5.2.1</strong></p></li>
<li><p>Polar encoding based on <strong>3GPP TS 38.212, Section 5.3.1</strong></p></li>
<li><p>Rate Matching with Sub-block interleaving, bit selection, and interleaving of coded bits based on <strong>3GPP
TS 38.212, Section 5.4.1</strong></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>payloadSize</strong> (<em>int</em>) – The size of input bitstream not including the CRC bits. This is the value <span class="math notranslate nohighlight">\(A\)</span> in <strong>3GPP TS 38.212,
Section 5.2.1</strong>.</p></li>
<li><p><strong>rateMatchedLen</strong> (<em>int</em>) – The total length of rate-matched output bitstream. This is the value <span class="math notranslate nohighlight">\(E\)</span> in <strong>3GPP TS 38.212,
Sections 5.3.1 and 5.4.1</strong>.</p></li>
<li><p><strong>dataType</strong> (<em>str</em><em> or </em><em>None</em>) – <p>The type of data using this Polar encoder/decoder. It can be one of the
following:</p>
<dl class="field-list simple">
<dt class="field-odd">”DCI”<span class="colon">:</span></dt>
<dd class="field-odd"><p>Downlink Control Information</p>
</dd>
<dt class="field-even">”UCI”<span class="colon">:</span></dt>
<dd class="field-even"><p>Uplink Control Information</p>
</dd>
<dt class="field-odd">”PBCH”<span class="colon">:</span></dt>
<dd class="field-odd"><p>Physical Broadcast Channel</p>
</dd>
<dt class="field-even">None<span class="colon">:</span></dt>
<dd class="field-even"><p>Customized Polar Coding.</p>
</dd>
</dl>
</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) – <p>A set of optional arguments depending on the <code class="docutils literal notranslate"><span class="pre">dataType</span></code>:</p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">iBIL<span class="colon">:</span></dt>
<dd class="field-odd"><p>Coded bits Interleaving flag. This is a boolean value that indicates whether coded bits
interleaving is enabled (<cite>True</cite>) or disabled (<cite>False</cite>). By default <code class="docutils literal notranslate"><span class="pre">iBIL=False</span></code>. This
is the value <span class="math notranslate nohighlight">\(I_{BIL}\)</span> in <strong>3GPP TS 38.212, Section 5.4.1.3</strong>. This parameter is ignored
if the <code class="docutils literal notranslate"><span class="pre">dataType</span></code> is not <cite>None</cite>. In this case, <code class="docutils literal notranslate"><span class="pre">iBIL</span></code> is set to <cite>True</cite> for
<code class="docutils literal notranslate"><span class="pre">dataType=&quot;UCI&quot;</span></code>, and <cite>False</cite> for <code class="docutils literal notranslate"><span class="pre">dataType=&quot;DCI&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">dataType=&quot;PBCH&quot;</span></code> cases.</p>
</dd>
<dt class="field-even">nMax<span class="colon">:</span></dt>
<dd class="field-even"><p>Max value of <span class="math notranslate nohighlight">\(n\)</span> where <span class="math notranslate nohighlight">\(N=2^n\)</span> is the length of the polar code. By default this
is set to 10 (which means <span class="math notranslate nohighlight">\(N=1024\)</span>. This is the value <span class="math notranslate nohighlight">\(N_{max}\)</span> in <strong>3GPP TS 38.212,
Section 5.3.1.2</strong>. This parameter is ignored if the <code class="docutils literal notranslate"><span class="pre">dataType</span></code> is not <cite>None</cite>. In this case,
<code class="docutils literal notranslate"><span class="pre">nMax=10</span></code> when <code class="docutils literal notranslate"><span class="pre">dataType=&quot;UCI&quot;</span></code>, and <code class="docutils literal notranslate"><span class="pre">nMax=9</span></code> for <code class="docutils literal notranslate"><span class="pre">dataType=&quot;DCI&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">dataType=&quot;PBCH&quot;</span></code>
cases.</p>
</dd>
<dt class="field-odd">iIL<span class="colon">:</span></dt>
<dd class="field-odd"><p>Input Interleaving flag. This is a boolean value that indicates whether input interleaving
is enabled (<cite>True</cite>) or disabled (<cite>False</cite>). By default <code class="docutils literal notranslate"><span class="pre">iIL=False</span></code>. This is the value
<span class="math notranslate nohighlight">\(I_{IL}\)</span> in <strong>3GPP TS 38.212, Section 5.3.1.1</strong>. This parameter is ignored if the
<code class="docutils literal notranslate"><span class="pre">dataType</span></code> is not <cite>None</cite>. In this case, <code class="docutils literal notranslate"><span class="pre">iIL</span></code> is set to <cite>False</cite> for <code class="docutils literal notranslate"><span class="pre">dataType=&quot;UCI&quot;</span></code>,
and <cite>True</cite> for <code class="docutils literal notranslate"><span class="pre">dataType=&quot;DCI&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">dataType=&quot;PBCH&quot;</span></code> cases.</p>
</dd>
<dt class="field-even">nPC<span class="colon">:</span></dt>
<dd class="field-even"><p>Total number of parity-check bits. By default this is set to 0. This is the value <span class="math notranslate nohighlight">\(N_{PC}\)</span>
in <strong>3GPP TS 38.212, Section 5.3.1</strong>. This parameter is ignored if the <code class="docutils literal notranslate"><span class="pre">dataType</span></code> is not
<cite>None</cite>. In this case, <code class="docutils literal notranslate"><span class="pre">nPC=0</span></code> when <code class="docutils literal notranslate"><span class="pre">dataType</span></code> is set to <code class="docutils literal notranslate"><span class="pre">&quot;DCI&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;PBCH&quot;</span></code>. For the
<code class="docutils literal notranslate"><span class="pre">&quot;UCI&quot;</span></code> case, this value may be set to 0 or 3 which is determined based on the procedure
explained in <strong>3GPP TS 38.212, Section 5.3.1.2</strong>.</p>
</dd>
<dt class="field-odd">nPCwm<span class="colon">:</span></dt>
<dd class="field-odd"><p>The number of <em>Low-weight</em>, <em>High-Reliability</em> parity-check bits out of the total parity-check
bits <code class="docutils literal notranslate"><span class="pre">nPC</span></code>. By default this is set to 0. This is the value <span class="math notranslate nohighlight">\(n_{PC}^{wm}\)</span> in <strong>3GPP TS
38.212, Sections 5.3.1.2, 6.3.1.3.1, and 6.3.2.3.1</strong>. This parameter is ignored if the
<code class="docutils literal notranslate"><span class="pre">dataType</span></code> is not <cite>None</cite>. In this case, <code class="docutils literal notranslate"><span class="pre">nPCwm=0</span></code> when <code class="docutils literal notranslate"><span class="pre">dataType</span></code> is set to <code class="docutils literal notranslate"><span class="pre">&quot;DCI&quot;</span></code>
or <code class="docutils literal notranslate"><span class="pre">&quot;PBCH&quot;</span></code>. For the <code class="docutils literal notranslate"><span class="pre">&quot;UCI&quot;</span></code> case, this value may be set to 0 or 1 which is determined based
on the procedure explained in <strong>3GPP TS 38.212, Sections 6.3.1.3.1 and 6.3.2.3.1</strong>.</p>
</dd>
<dt class="field-even">iSeg<span class="colon">:</span></dt>
<dd class="field-even"><p>Segmentation flag. This is a boolean value that indicates whether segmentation is enabled
(<cite>True</cite>) or disabled (<cite>False</cite>). By default <code class="docutils literal notranslate"><span class="pre">iSeg=False</span></code>. This is the value <span class="math notranslate nohighlight">\(I_{seg}\)</span>
in <strong>3GPP TS 38.212, Section 5.2.1</strong>. This parameter is ignored if the <code class="docutils literal notranslate"><span class="pre">dataType</span></code> is not
<cite>None</cite>. In this case, <code class="docutils literal notranslate"><span class="pre">iSeg=False</span></code> when <code class="docutils literal notranslate"><span class="pre">dataType=&quot;DCI&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">dataType=&quot;PBCH&quot;</span></code>. When
<code class="docutils literal notranslate"><span class="pre">dataType=&quot;UCI&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">iSeg</span></code> is set based on the value of <code class="docutils literal notranslate"><span class="pre">payloadSize</span></code>.</p>
</dd>
<dt class="field-odd">crcPoly<span class="colon">:</span></dt>
<dd class="field-odd"><p>The CRC polynomial. This is a string specifying the CRC polynomial or <cite>None</cite>. If
specified, it must be one of the values specified in
<a class="reference internal" href="#neoradium.chancodebase.ChanCodeBase.getCrc" title="neoradium.chancodebase.ChanCodeBase.getCrc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getCrc()</span></code></a> for the <code class="docutils literal notranslate"><span class="pre">poly</span></code> parameter. The default
value is <code class="docutils literal notranslate"><span class="pre">&quot;11&quot;</span></code>. This parameter is ignored if the <code class="docutils literal notranslate"><span class="pre">dataType</span></code> is not <cite>None</cite>. In this case
<code class="docutils literal notranslate"><span class="pre">crcPoly</span></code> is set to <code class="docutils literal notranslate"><span class="pre">&quot;6&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;11&quot;</span></code> depending on <code class="docutils literal notranslate"><span class="pre">payloadSize</span></code> for <code class="docutils literal notranslate"><span class="pre">dataType=&quot;UCI&quot;</span></code>,
and <code class="docutils literal notranslate"><span class="pre">&quot;24C&quot;</span></code> for <code class="docutils literal notranslate"><span class="pre">dataType=&quot;DCI&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">dataType=&quot;PBCH&quot;</span></code> cases.</p>
</dd>
</dl>
</div></blockquote>
</p></li>
</ul>
</dd>
</dl>
<p><strong>Other Properties:</strong></p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">rateMatchedBlockLen<span class="colon">:</span></dt>
<dd class="field-odd"><p>The number of rate-matched bits transmitted for each code block when segmented. This
is the same as <code class="docutils literal notranslate"><span class="pre">rateMatchedLen</span></code> if segmentation is disabled. This is the value <span class="math notranslate nohighlight">\(E_r\)</span> in
<strong>3GPP TS 38.212, Section 5.5</strong>.</p>
</dd>
<dt class="field-even">codeBlockSize<span class="colon">:</span></dt>
<dd class="field-even"><p>The code block size. This is the value <span class="math notranslate nohighlight">\(K\)</span> in <strong>3GPP TS 38.212, Section 5.3.1</strong>
which includes the CRC bits (if any).</p>
</dd>
<dt class="field-odd">polarCodeSize<span class="colon">:</span></dt>
<dd class="field-odd"><p>The polar code size <span class="math notranslate nohighlight">\(N\)</span>. This is always a power of 2.</p>
</dd>
<dt class="field-even">msgBits<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of indices of the message bits in the coded bitstream.</p>
</dd>
<dt class="field-odd">frozenBits<span class="colon">:</span></dt>
<dd class="field-odd"><p>A list of indices of the <em>frozen bits</em> in the coded bitstream.</p>
</dd>
<dt class="field-even">pcBits<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of indices of the parity-check bits in the coded bitstream. This can be empty depending
on <code class="docutils literal notranslate"><span class="pre">nPC</span></code>.</p>
</dd>
<dt class="field-odd">generator<span class="colon">:</span></dt>
<dd class="field-odd"><p>The polar coding <em>generator</em> matrix as a 2-D NumPy array.</p>
</dd>
</dl>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="neoradium.polar.PolarEncoder.print">
<span class="sig-name descname"><span class="pre">print</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">getStr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#neoradium.polar.PolarEncoder.print" title="Link to this definition"></a></dt>
<dd><p>Prints the properties of this <a class="reference internal" href="#neoradium.polar.PolarEncoder" title="neoradium.polar.PolarEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolarEncoder</span></code></a> object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indent</strong> (<em>int</em>) – The number of indentation characters.</p></li>
<li><p><strong>title</strong> (<em>str</em>) – If specified, it is used as a title for the printed information.</p></li>
<li><p><strong>getStr</strong> (<em>Boolean</em>) – If <cite>True</cite>, returns a text string instead of printing it.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the <code class="docutils literal notranslate"><span class="pre">getStr</span></code> parameter is <cite>True</cite>, then this function returns the information in a text string.
Otherwise, nothing is returned.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None or str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="neoradium.polar.PolarEncoder.doSegmentation">
<span class="sig-name descname"><span class="pre">doSegmentation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">txBlock</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#neoradium.polar.PolarEncoder.doSegmentation" title="Link to this definition"></a></dt>
<dd><p>If segmentation is enabled, the first step in Polar encoding process is breaking down the transport block
into smaller code blocks. This function receives a transport block <code class="docutils literal notranslate"><span class="pre">txBlock</span></code>, performs segmentation
depending on the value of <code class="docutils literal notranslate"><span class="pre">iSeg</span></code> property based on <strong>3GPP TS 38.212, Section 5.2.1</strong>, and outputs a 2D
<code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">x</span> <span class="pre">K</span></code> NumPy array containing <code class="docutils literal notranslate"><span class="pre">C</span></code> code blocks of length <code class="docutils literal notranslate"><span class="pre">K</span></code>. Note that <code class="docutils literal notranslate"><span class="pre">C</span></code> can only be 1 or 2 and
if <code class="docutils literal notranslate"><span class="pre">iSeg=False</span></code>, then <code class="docutils literal notranslate"><span class="pre">C=1</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>txBlock</strong> (<em>NumPy array</em>) – A NumPy array of bits containing the transport block information.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A 2D <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">x</span> <span class="pre">K</span></code> NumPy array containing <code class="docutils literal notranslate"><span class="pre">C</span></code> code blocks of length <code class="docutils literal notranslate"><span class="pre">K</span></code>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>NumPy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="neoradium.polar.PolarEncoder.encode">
<span class="sig-name descname"><span class="pre">encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">codeBlocks</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#neoradium.polar.PolarEncoder.encode" title="Link to this definition"></a></dt>
<dd><p>This function encodes a set of code blocks and returns a set of Polar-coded code blocks based on the procedure
explained in <strong>3GPP TS 38.212, Section 5.3.1</strong>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>codeBlocks</strong> (<em>NumPy array</em>) – A <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">x</span> <span class="pre">K</span></code> NumPy array containing <code class="docutils literal notranslate"><span class="pre">C</span></code> code blocks of length <code class="docutils literal notranslate"><span class="pre">K</span></code> being Polar-encoded by this function.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">x</span> <span class="pre">N</span></code> NumPy array containing the <code class="docutils literal notranslate"><span class="pre">C</span></code> encoded code blocks.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>NumPy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="neoradium.polar.PolarEncoder.rateMatch">
<span class="sig-name descname"><span class="pre">rateMatch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">codeBlocks</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#neoradium.polar.PolarEncoder.rateMatch" title="Link to this definition"></a></dt>
<dd><p>This function receives a set of encoded code blocks and returns the rate-matched code blocks. It first performs
Sub-block interleaving based on <strong>3GPP TS 38.212, Section 5.4.1.1</strong>, then bit selection is done based on
<strong>3GPP TS 38.212, Section 5.4.1.2</strong>. Finally, if <em>Coded bits Interleaving</em> is enabled (<code class="docutils literal notranslate"><span class="pre">iBIL=True</span></code>), this
function applies the procedure in <strong>3GPP TS 38.212, Section 5.4.1.3</strong> for <em>Coded bits Interleaving</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>codeBlocks</strong> (<em>NumPy array</em>) – A <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">x</span> <span class="pre">N</span></code> NumPy array containing <code class="docutils literal notranslate"><span class="pre">C</span></code> encoded code blocks of length <code class="docutils literal notranslate"><span class="pre">N</span></code> being rate-matched by
this function.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">x</span> <span class="pre">E</span></code> NumPy array containing the <code class="docutils literal notranslate"><span class="pre">C</span></code> rate-matched code blocks of length <code class="docutils literal notranslate"><span class="pre">E</span></code> where
<code class="docutils literal notranslate"><span class="pre">E=rateMatchedBlockLen</span></code>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>NumPy array</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="neoradium.polar.PolarDecoder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">neoradium.polar.</span></span><span class="sig-name descname"><span class="pre">PolarDecoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">payloadSize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rateMatchedLen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dataType</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#neoradium.polar.PolarDecoder" title="Link to this definition"></a></dt>
<dd><p>This class is used to decode a set of Log-Likelihood-Ratios (LLRs) to a transport block using the Successive
Cancellation List (SCL) <a class="footnote-reference brackets" href="#id9" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> algorithm. It is derived from the <a class="reference internal" href="#neoradium.polar.PolarBase" title="neoradium.polar.PolarBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolarBase</span></code></a> class and performs rate
recovery and Polar decoding which are basically the opposite of the encoding tasks performed in reverse order.</p>
<p>The following example shows a typical use case for decoding the received Polar-coded information into transport
blocks:</p>
<div class="literal-block-wrapper docutils container" id="id12">
<div class="code-block-caption"><span class="caption-text">An example of Polar decoding</span><a class="headerlink" href="#id12" title="Link to this code"></a></div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">payloadLen</span> <span class="o">=</span> <span class="mi">30</span>             <span class="c1"># A</span>
<span class="n">rateMatchedLen</span> <span class="o">=</span> <span class="mi">120</span>        <span class="c1"># E</span>

<span class="c1"># Creating a polar decoder object for &quot;DCI&quot; data</span>
<span class="n">polarDecoder</span> <span class="o">=</span> <span class="n">PolarDecoder</span><span class="p">(</span><span class="n">payloadLen</span><span class="p">,</span> <span class="n">rateMatchedLen</span><span class="p">,</span> <span class="s1">&#39;dci&#39;</span><span class="p">,</span> <span class="n">sclListSize</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">useMinsum</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Rate recovery (Assuming &quot;llrs&quot; contains the LLR values from demodulation process)</span>
<span class="n">rateRecoveredRxBlocks</span> <span class="o">=</span> <span class="n">polarDecoder</span><span class="o">.</span><span class="n">recoverRate</span><span class="p">(</span><span class="n">llrs</span><span class="p">)</span>

<span class="c1"># Polar Decoding using SCL algorithm</span>
<span class="n">decTxBlock</span><span class="p">,</span> <span class="n">numCrcErrors</span> <span class="o">=</span> <span class="n">polarDecoder</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">rateRecoveredRxBlocks</span><span class="p">)</span>
</pre></div>
</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>payloadSize</strong> (<em>int</em>) – The size of input bitstream not including the CRC bits. This is the value <span class="math notranslate nohighlight">\(A\)</span> in <strong>3GPP TS 38.212,
Section 5.2.1</strong>.</p></li>
<li><p><strong>rateMatchedLen</strong> (<em>int</em>) – The total length of rate-matched output bitstream. This is the value <span class="math notranslate nohighlight">\(E\)</span> in <strong>3GPP TS 38.212,
Sections 5.3.1 and 5.4.1</strong>.</p></li>
<li><p><strong>dataType</strong> (<em>str</em><em> or </em><em>None</em>) – <p>The type of data using this Polar decoder. It can be one of the following:</p>
<dl class="field-list simple">
<dt class="field-odd">”DCI”<span class="colon">:</span></dt>
<dd class="field-odd"><p>Downlink Control Information</p>
</dd>
<dt class="field-even">”UCI”<span class="colon">:</span></dt>
<dd class="field-even"><p>Uplink Control Information</p>
</dd>
<dt class="field-odd">”PBCH”<span class="colon">:</span></dt>
<dd class="field-odd"><p>Physical broadcast channel</p>
</dd>
<dt class="field-even">None<span class="colon">:</span></dt>
<dd class="field-even"><p>Customized Polar Coding.</p>
</dd>
</dl>
</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) – <p>A set of optional arguments depending on the <code class="docutils literal notranslate"><span class="pre">dataType</span></code>:</p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">iBIL<span class="colon">:</span></dt>
<dd class="field-odd"><p>Coded bits Interleaving flag. This is a boolean value that indicates whether coded bits
interleaving is enabled (<cite>True</cite>) or disabled (<cite>False</cite>). By default <code class="docutils literal notranslate"><span class="pre">iBIL=False</span></code>. This
is the value <span class="math notranslate nohighlight">\(I_{BIL}\)</span> in <strong>3GPP TS 38.212, Section 5.4.1.3</strong>. This parameter is ignored
if the <code class="docutils literal notranslate"><span class="pre">dataType</span></code> is not <cite>None</cite>. In this case, <code class="docutils literal notranslate"><span class="pre">iBIL</span></code> is set to <cite>True</cite> for
<code class="docutils literal notranslate"><span class="pre">dataType=&quot;UCI&quot;</span></code>, and <cite>False</cite> for <code class="docutils literal notranslate"><span class="pre">dataType=&quot;DCI&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">dataType=&quot;PBCH&quot;</span></code> cases.</p>
</dd>
<dt class="field-even">nMax<span class="colon">:</span></dt>
<dd class="field-even"><p>Max value of <span class="math notranslate nohighlight">\(n\)</span> where <span class="math notranslate nohighlight">\(N=2^n\)</span> is the length of the polar code. By default this
is set to 10 (which means <span class="math notranslate nohighlight">\(N=1024\)</span>. This is the value <span class="math notranslate nohighlight">\(N_{max}\)</span> in <strong>3GPP TS 38.212,
Section 5.3.1.2</strong>. This parameter is ignored if the <code class="docutils literal notranslate"><span class="pre">dataType</span></code> is not <cite>None</cite>. In this case,
<code class="docutils literal notranslate"><span class="pre">nMax=10</span></code> when <code class="docutils literal notranslate"><span class="pre">dataType=&quot;UCI&quot;</span></code>, and <code class="docutils literal notranslate"><span class="pre">nMax=9</span></code> for <code class="docutils literal notranslate"><span class="pre">dataType=&quot;DCI&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">dataType=&quot;PBCH&quot;</span></code>
cases.</p>
</dd>
<dt class="field-odd">iIL<span class="colon">:</span></dt>
<dd class="field-odd"><p>Input Interleaving flag. This is a boolean value that indicates whether input interleaving
is enabled (<cite>True</cite>) or disabled (<cite>False</cite>). By default <code class="docutils literal notranslate"><span class="pre">iIL=False</span></code>. This is the value
<span class="math notranslate nohighlight">\(I_{IL}\)</span> in <strong>3GPP TS 38.212, Section 5.3.1.1</strong>. This parameter is ignored if the
<code class="docutils literal notranslate"><span class="pre">dataType</span></code> is not <cite>None</cite>. In this case, <code class="docutils literal notranslate"><span class="pre">iIL</span></code> is set to <cite>False</cite> for <code class="docutils literal notranslate"><span class="pre">dataType=&quot;UCI&quot;</span></code>,
and <cite>True</cite> for <code class="docutils literal notranslate"><span class="pre">dataType=&quot;DCI&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">dataType=&quot;PBCH&quot;</span></code> cases.</p>
</dd>
<dt class="field-even">nPC<span class="colon">:</span></dt>
<dd class="field-even"><p>Total number of parity-check bits. By default this is set to 0. This is the value <span class="math notranslate nohighlight">\(N_{PC}\)</span>
in <strong>3GPP TS 38.212, Section 5.3.1</strong>. This parameter is ignored if the <code class="docutils literal notranslate"><span class="pre">dataType</span></code> is not
<cite>None</cite>. In this case, <code class="docutils literal notranslate"><span class="pre">nPC=0</span></code> when <code class="docutils literal notranslate"><span class="pre">dataType</span></code> is set to <code class="docutils literal notranslate"><span class="pre">&quot;DCI&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;PBCH&quot;</span></code>. For the
<code class="docutils literal notranslate"><span class="pre">&quot;UCI&quot;</span></code> case, this value may be set to 0 or 3 which is determined based on the procedure
explained in <strong>3GPP TS 38.212, Section 5.3.1.2</strong>.</p>
</dd>
<dt class="field-odd">nPCwm<span class="colon">:</span></dt>
<dd class="field-odd"><p>The number of <em>Low-weight</em>, <em>High-Reliability</em> parity-check bits out of the total parity-check
bits <code class="docutils literal notranslate"><span class="pre">nPC</span></code>. By default this is set to 0. This is the value <span class="math notranslate nohighlight">\(n_{PC}^{wm}\)</span> in <strong>3GPP TS
38.212, Sections 5.3.1.2, 6.3.1.3.1, and 6.3.2.3.1</strong>. This parameter is ignored if the
<code class="docutils literal notranslate"><span class="pre">dataType</span></code> is not <cite>None</cite>. In this case, <code class="docutils literal notranslate"><span class="pre">nPCwm=0</span></code> when <code class="docutils literal notranslate"><span class="pre">dataType</span></code> is set to <code class="docutils literal notranslate"><span class="pre">&quot;DCI&quot;</span></code>
or <code class="docutils literal notranslate"><span class="pre">&quot;PBCH&quot;</span></code>. For the <code class="docutils literal notranslate"><span class="pre">&quot;UCI&quot;</span></code> case, this value may be set to 0 or 1 which is determined based
on the procedure explained in <strong>3GPP TS 38.212, Sections 6.3.1.3.1 and 6.3.2.3.1</strong>.</p>
</dd>
<dt class="field-even">iSeg<span class="colon">:</span></dt>
<dd class="field-even"><p>Segmentation flag. This is a boolean value that indicates whether segmentation is enabled
(<cite>True</cite>) or disabled (<cite>False</cite>). By default <code class="docutils literal notranslate"><span class="pre">iSeg=False</span></code>. This is the value <span class="math notranslate nohighlight">\(I_{seg}\)</span>
in <strong>3GPP TS 38.212, Section 5.2.1</strong>. This parameter is ignored if the <code class="docutils literal notranslate"><span class="pre">dataType</span></code> is not
<cite>None</cite>. In this case, <code class="docutils literal notranslate"><span class="pre">iSeg=False</span></code> when <code class="docutils literal notranslate"><span class="pre">dataType=&quot;DCI&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">dataType=&quot;PBCH&quot;</span></code>. When
<code class="docutils literal notranslate"><span class="pre">dataType=&quot;UCI&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">iSeg</span></code> is set based on the value of <code class="docutils literal notranslate"><span class="pre">payloadSize</span></code>.</p>
</dd>
<dt class="field-odd">crcPoly<span class="colon">:</span></dt>
<dd class="field-odd"><p>The CRC polynomial. This is a string specifying the CRC polynomial or <cite>None</cite>. If
specified, it must be one of the values specified in
<a class="reference internal" href="#neoradium.chancodebase.ChanCodeBase.getCrc" title="neoradium.chancodebase.ChanCodeBase.getCrc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getCrc()</span></code></a> for the <code class="docutils literal notranslate"><span class="pre">poly</span></code> parameter. The default
value is <code class="docutils literal notranslate"><span class="pre">&quot;11&quot;</span></code>. This parameter is ignored if the <code class="docutils literal notranslate"><span class="pre">dataType</span></code> is not <cite>None</cite>. In this case
<code class="docutils literal notranslate"><span class="pre">crcPoly</span></code> is set to <code class="docutils literal notranslate"><span class="pre">&quot;6&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;11&quot;</span></code> depending on <code class="docutils literal notranslate"><span class="pre">payloadSize</span></code> for <code class="docutils literal notranslate"><span class="pre">dataType=&quot;UCI&quot;</span></code>,
and <code class="docutils literal notranslate"><span class="pre">&quot;24C&quot;</span></code> for <code class="docutils literal notranslate"><span class="pre">dataType=&quot;DCI&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">dataType=&quot;PBCH&quot;</span></code> cases.</p>
</dd>
<dt class="field-even">sclListSize<span class="colon">:</span></dt>
<dd class="field-even"><p>The list size of the <em>Successive Cancellation List (SCL)</em> algorithm used for decoding.
The default is 8.</p>
</dd>
<dt class="field-odd">useMinsum<span class="colon">:</span></dt>
<dd class="field-odd"><p>A Boolean value indicating whether the <em>Min-Sum</em> approximation should be used in the SCL
algorithm. <cite>True</cite> (default) means the “Min-Sum” approximation is used resulting in faster
decoding with slightly less precise results. <cite>False</cite> means the actual extrinsic likelihood
function based on hyperbolic tangent function is used.</p>
</dd>
</dl>
</div></blockquote>
</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For a pair of <a class="reference internal" href="#neoradium.polar.PolarEncoder" title="neoradium.polar.PolarEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolarEncoder</span></code></a>/<a class="reference internal" href="#neoradium.polar.PolarDecoder" title="neoradium.polar.PolarDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolarDecoder</span></code></a> objects to work properly, the
above parameters used to configure them should match.</p>
</div>
<p>Please refer to <a class="reference internal" href="#neoradium.polar.PolarBase" title="neoradium.polar.PolarBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolarBase</span></code></a> class for a list of properties inherited from the base class.</p>
<dl class="py method">
<dt class="sig sig-object py" id="neoradium.polar.PolarDecoder.print">
<span class="sig-name descname"><span class="pre">print</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">getStr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#neoradium.polar.PolarDecoder.print" title="Link to this definition"></a></dt>
<dd><p>Prints the properties of this <a class="reference internal" href="#neoradium.polar.PolarDecoder" title="neoradium.polar.PolarDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolarDecoder</span></code></a> object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indent</strong> (<em>int</em>) – The number of indentation characters.</p></li>
<li><p><strong>title</strong> (<em>str</em>) – If specified, it is used as a title for the printed information.</p></li>
<li><p><strong>getStr</strong> (<em>Boolean</em>) – If <cite>True</cite>, returns a text string instead of printing it.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If the <code class="docutils literal notranslate"><span class="pre">getStr</span></code> parameter is <cite>True</cite>, then this function returns the information in a text string.
Otherwise, nothing is returned.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None or str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="neoradium.polar.PolarDecoder.recoverRate">
<span class="sig-name descname"><span class="pre">recoverRate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rxBlock</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#neoradium.polar.PolarDecoder.recoverRate" title="Link to this definition"></a></dt>
<dd><p>This function receives an array of Log-Likelihood Ratios (LLRs) in <code class="docutils literal notranslate"><span class="pre">rxBlock</span></code> and returns a set of
rate-recovered LLRs for each code block which are ready for Polar decoding. This function does the exact opposite
of the <a class="reference internal" href="#neoradium.polar.PolarEncoder" title="neoradium.polar.PolarEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolarEncoder</span></code></a>’s <code class="xref py py-meth docutils literal notranslate"><span class="pre">rateMatch()</span></code> method. Note that while the <code class="xref py py-meth docutils literal notranslate"><span class="pre">rateMatch()</span></code>
works with bits, this method works on LLRs which are usually obtained by performing demodulation process.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>rxBlock</strong> (<em>NumPy array</em>) – A NumPy array of Log-Likelihood Ratios (LLRs) obtained as a result of demodulation process. Each element
is a real LLR value corresponding to a each received bit. The larger the LLR value, the more likely it is
for that bit to be a <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">x</span> <span class="pre">N</span></code> NumPy array of <code class="docutils literal notranslate"><span class="pre">C</span></code> received coded blocks of length <code class="docutils literal notranslate"><span class="pre">N</span></code> containing the LLR values for
each coded block ready to be polar-decoded.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>NumPy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="neoradium.polar.PolarDecoder.decode">
<span class="sig-name descname"><span class="pre">decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rxLlrBlocks</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#neoradium.polar.PolarDecoder.decode" title="Link to this definition"></a></dt>
<dd><p>This function implements the <em>Successive Cancellation List (SCL)</em> algorithm for Polar-decoding of LLRs into
decoded transport blocks. This implementation was inspired mostly by <a class="reference external" href="https://www.youtube.com/playlist?list=PLyqSpQzTE6M81HJ26ZaNv0V3ROBrcv-Kc">LDPC and Polar Codes in 5G Standard</a> set of videos and was written
from scratch using a recursive algorithm to efficiently perform the SCL decoding process.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>rxLlrBlocks</strong> (<em>NumPy array</em>) – A <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">x</span> <span class="pre">N</span></code> NumPy array of <code class="docutils literal notranslate"><span class="pre">C</span></code> received coded blocks of length <code class="docutils literal notranslate"><span class="pre">N</span></code> containing the LLR values for each
coded block.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>txBlock</strong> (<em>NumPy array of bits</em>) – A 1D NumPy array of length <span class="math notranslate nohighlight">\(A\)</span> containing the decoded transport block bits where <span class="math notranslate nohighlight">\(A\)</span> is
equal to the parameter <code class="docutils literal notranslate"><span class="pre">payloadSize</span></code>.</p></li>
<li><p><strong>numCrcErrors</strong> (<em>int</em>) – The total number of CRC errors if <code class="docutils literal notranslate"><span class="pre">crcPoly</span></code> is not <cite>None</cite>, otherwise, zero.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<hr class="docutils" />
<p><strong>References:</strong></p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id8" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">1</a><span class="fn-bracket">]</span></span>
<p>5G NR: The Next Generation Wireless Access Technology by Erik
Dahlman, Stefan Parkvall, and Johan Skold (Fig. 9.3)</p>
</aside>
<aside class="footnote brackets" id="id9" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">2</a><span class="fn-bracket">]</span></span>
<p>I. Tal and A. Vardy, “List decoding of polar codes,” IEEE Transactions
on Information Theory, vol. 61, no. 5, pp. 2213–2226, 2015.</p>
</aside>
</aside>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="PhyChannels.html" class="btn btn-neutral float-left" title="Physical Channels" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Harq.html" class="btn btn-neutral float-right" title="HARQ" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, InterDigital, Inc. All Rights Reserved.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>